// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/lib/golang/src/vendor/github.com/golang-fips/openssl-fips/openssl/ecdh.go:1:1
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && !android && !cmd_go_bootstrap && !msan && !no_openssl && !static
// +build linux,!android,!cmd_go_bootstrap,!msan,!no_openssl,!static

package openssl

// #include "goopenssl.h"
import _ "unsafe"
import (
	"errors"
	"runtime"
	"unsafe"
)

var (
	paramPrivKey = ( /*line :19:17*/_Cfunc_CString /*line :19:25*/)("priv")
)

type PublicKeyECDH struct {
	_pkey * /*line :23:9*/_Ctype_GO_EVP_PKEY /*line :23:22*/
	bytes []byte

	// priv is only set when PublicKeyECDH is derived from a private key,
	// in which case priv's finalizer is responsible for freeing _pkey.
	// This ensures priv is not finalized while the public key is alive,
	// which could cause use-after-free and double-free behavior.
	//
	// We could avoid this altogether by using EVP_PKEY_up_ref
	// when instantiating a derived public key, unfortunately
	// it is not available on OpenSSL 1.0.2.
	priv *PrivateKeyECDH
}

func (k *PublicKeyECDH) finalize() {
	if k.priv == nil {
		func() { _cgo0 := /*line :39:35*/k._pkey; _cgoCheckPointer(_cgo0, nil); /*line :39:43*/_Cfunc__goboringcrypto_EVP_PKEY_free(_cgo0); }()
	}
}

type PrivateKeyECDH struct {
	_pkey        * /*line :44:16*/_Ctype_GO_EVP_PKEY /*line :44:29*/
	curve        string
	hasPublicKey bool
}

func (k *PrivateKeyECDH) finalize() {
	func() { _cgo0 := /*line :50:34*/k._pkey; _cgoCheckPointer(_cgo0, nil); /*line :50:42*/_Cfunc__goboringcrypto_EVP_PKEY_free(_cgo0); }()
}

func NewPublicKeyECDH(curve string, bytes []byte) (*PublicKeyECDH, error) {
	if len(bytes) < 1 {
		return nil, errors.New("NewPublicKeyECDH: missing key")
	}
	pkey, err := newECDHPkey(curve, bytes, false)
	if err != nil {
		return nil, err
	}
	k := &PublicKeyECDH{pkey, append([]byte(nil), bytes...), nil}
	runtime.SetFinalizer(k, (*PublicKeyECDH).finalize)
	return k, nil
}

func (k *PublicKeyECDH) Bytes() []byte { return k.bytes }

func NewPrivateKeyECDH(curve string, bytes []byte) (*PrivateKeyECDH, error) {
	pkey, err := newECDHPkey(curve, bytes, true)
	if err != nil {
		return nil, err
	}
	k := &PrivateKeyECDH{pkey, curve, false}
	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
	return k, nil
}

func (k *PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error) {
	defer runtime.KeepAlive(k)
	if !k.hasPublicKey {
		err := deriveEcdhPublicKey(k._pkey, k.curve)
		if err != nil {
			return nil, err
		}
		k.hasPublicKey = true
	}
	var bytes []byte
	var cbytes * /*line :88:14*/_Ctype_uchar /*line :88:21*/

	n := func() _Ctype_size_t{ _cgo0 := /*line :90:63*/k._pkey; _cgoBase1 := /*line :90:72*/&cbytes; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :90:80*/_Cfunc__goboringcrypto_EVP_PKEY_get1_encoded_ecdh_public_key(_cgo0, _cgo1); }()
	if n == 0 {
		return nil, NewOpenSSLError("EVP_PKEY_get1_encoded_ecdh_public_key")
	}
	bytes = func() []byte{ _cgo0 := /*line :94:20*/unsafe.Pointer(cbytes); var _cgo1 _Ctype_int = _Ctype_int /*line :94:49*/(n); _cgoCheckPointer(_cgo0, nil); return /*line :94:53*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :95:9*/unsafe.Pointer(cbytes); _cgoCheckPointer(_cgo0, nil); /*line :95:32*/_Cfunc_free(_cgo0); }()

	pub := &PublicKeyECDH{k._pkey, bytes, k}
	runtime.SetFinalizer(pub, (*PublicKeyECDH).finalize)
	return pub, nil
}

func newECDHPkey(curve string, bytes []byte, isPrivate bool) (* /*line :102:64*/_Ctype_GO_EVP_PKEY /*line :102:77*/, error) {
	nid, err := curveNID(curve)
	if err != nil {
		return nil, err
	}

	var isPrivateValue  /*line :108:21*/_Ctype_int /*line :108:26*/
	if isPrivate {
		isPrivateValue = 1
	} else {
		if len(bytes) > 0 && bytes[0] != 0x04 {
			return nil, errors.New("crypto/ecdh: point is compressed")
		} else if len(bytes) == 1 && bytes[0] == 0x00 {
			return nil, errors.New("crypto/ecdh: point at infinity")
		}
	}

	key := ( /*line :119:9*/_Cfunc__goboringcrypto_EVP_PKEY_new_for_ecdh /*line :119:47*/)(nid, base(bytes),  /*line :119:67*/_Ctype_size_t /*line :119:75*/(len(bytes)), isPrivateValue)
	if key == nil {
		return nil, NewOpenSSLError("EVP_PKEY_new_for_ecdh")
	}
	return key, nil
}

// deriveEcdhPublicKey sets the raw public key of pkey by deriving it from
// the raw private key.
func deriveEcdhPublicKey(pkey * /*line :128:32*/_Ctype_GO_EVP_PKEY /*line :128:45*/, curve string) error {
	nid, _ := curveNID(curve)
	if func() _Ctype_int{ _cgo0 := /*line :130:65*/pkey; var _cgo1 _Ctype_int = /*line :130:71*/nid; _cgoCheckPointer(_cgo0, nil); return /*line :130:75*/_Cfunc__goboringcrypto_EVP_PKEY_set_ecdh_public_key_from_private(_cgo0, _cgo1); }() != 1 {
		return NewOpenSSLError("EVP_PKEY_set_ecdh_public_key_from_private")
	}
	return nil
}

func encodeEcPoint(group * /*line :136:27*/_Ctype_GO_EC_GROUP /*line :136:40*/, pt * /*line :136:46*/_Ctype_GO_EC_POINT /*line :136:59*/) ([]byte, error) {
	// Get encoded point size.
	n := func() _Ctype_size_t{ _cgo0 := /*line :138:44*/group; _cgo1 := /*line :138:51*/pt; var _cgo2 _Ctype_point_conversion_form_t = /*line :138:55*/_Ciconst_GO_POINT_CONVERSION_UNCOMPRESSED /*line :138:89*/; var _cgo3 *_Ctype_uchar = /*line :138:91*/nil; var _cgo4 _Ctype_size_t = /*line :138:96*/0; var _cgo5 *_Ctype_struct_bignum_ctx = /*line :138:99*/nil; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :138:103*/_Cfunc__goboringcrypto_EC_POINT_point2oct(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if n == 0 {
		return nil, NewOpenSSLError("EC_POINT_point2oct")
	}
	// Encode point into bytes.
	bytes := make([]byte, n)
	n = func() _Ctype_size_t{ _cgo0 := /*line :144:43*/group; _cgo1 := /*line :144:50*/pt; var _cgo2 _Ctype_point_conversion_form_t = /*line :144:54*/_Ciconst_GO_POINT_CONVERSION_UNCOMPRESSED /*line :144:88*/; var _cgo3 *_Ctype_uchar = /*line :144:90*/base(bytes); var _cgo4 _Ctype_size_t = /*line :144:103*/n; var _cgo5 *_Ctype_struct_bignum_ctx = /*line :144:106*/nil; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :144:110*/_Cfunc__goboringcrypto_EC_POINT_point2oct(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if n == 0 {
		return nil, NewOpenSSLError("EC_POINT_point2oct")
	}
	return bytes, nil
}

func ECDH(priv *PrivateKeyECDH, pub *PublicKeyECDH) ([]byte, error) {
	defer runtime.KeepAlive(priv)
	defer runtime.KeepAlive(pub)
	ctx := func() *_Ctype_struct_evp_pkey_ctx_st{ _cgo0 := /*line :154:44*/priv._pkey; var _cgo1 *_Ctype_struct_engine_st = /*line :154:56*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :154:60*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_new(_cgo0, _cgo1); }()
	if ctx == nil {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_new")
	}
	defer func() func() { _cgo0 := /*line :158:44*/ctx; return func() { _cgoCheckPointer(_cgo0, nil); /*line :158:48*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_free(_cgo0); }}()()
	if func() _Ctype_int{ _cgo0 := /*line :159:44*/ctx; _cgoCheckPointer(_cgo0, nil); return /*line :159:48*/_Cfunc__goboringcrypto_EVP_PKEY_derive_init(_cgo0); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_derive_init")
	}
	if func() _Ctype_int{ _cgo0 := /*line :162:51*/ctx; _cgo1 := /*line :162:56*/pub._pkey; var _cgo2 _Ctype_int = /*line :162:67*/1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :162:69*/_Cfunc__goboringcrypto_EVP_PKEY_derive_set_peer_ex(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_derive_set_peer_ex")
	}
	var outLen  /*line :165:13*/_Ctype_size_t /*line :165:21*/
	if func() _Ctype_int{ _cgo0 := /*line :166:39*/ctx; var _cgo1 *_Ctype_uchar = /*line :166:44*/nil; var _cgo2 *_Ctype_size_t = /*line :166:49*/&outLen; _cgoCheckPointer(_cgo0, nil); return /*line :166:57*/_Cfunc__goboringcrypto_EVP_PKEY_derive(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_derive_init")
	}
	out := make([]byte, outLen)
	if func() _Ctype_int{ _cgo0 := /*line :170:39*/ctx; var _cgo1 *_Ctype_uchar = /*line :170:44*/base(out); var _cgo2 *_Ctype_size_t = /*line :170:55*/&outLen; _cgoCheckPointer(_cgo0, nil); return /*line :170:63*/_Cfunc__goboringcrypto_EVP_PKEY_derive(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_derive_init")
	}
	return out, nil
}

func GenerateKeyECDH(curve string) (*PrivateKeyECDH, []byte, error) {
	pkey, err := generateEVPPKey(( /*line :177:31*/_Ciconst_GO_EVP_PKEY_EC /*line :177:46*/), 0, curve)
	if err != nil {
		return nil, nil, err
	}
	var k *PrivateKeyECDH
	defer func() {
		if k == nil {
			func() { _cgo0 := /*line :184:36*/pkey; _cgoCheckPointer(_cgo0, nil); /*line :184:41*/_Cfunc__goboringcrypto_EVP_PKEY_free(_cgo0); }()
		}
	}()
	var priv * /*line :187:12*/_Ctype_GO_BIGNUM /*line :187:23*/
	if openSSLVersion() < OPENSSL_VERSION_3_0_0 {
		key := getECKey(pkey)
		priv = func() *_Ctype_struct_bignum_st{ _cgo0 := /*line :190:52*/key; _cgoCheckPointer(_cgo0, nil); return /*line :190:56*/_Cfunc__goboringcrypto_EC_KEY_get0_private_key(_cgo0); }()
		if priv == nil {
			return nil, nil, NewOpenSSLError("EC_KEY_get0_private_key")
		}
	} else {
		if func() _Ctype_int{ _cgo0 := /*line :195:46*/pkey; var _cgo1 *_Ctype_char = /*line :195:52*/paramPrivKey; _cgoBase2 := /*line :195:66*/&priv; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :195:72*/_Cfunc__goboringcrypto_EVP_PKEY_get_bn_param(_cgo0, _cgo1, _cgo2); }() != 1 {
			return nil, nil, NewOpenSSLError("EVP_PKEY_get_bn_param")
		}
		defer func() func() { _cgo0 := /*line :198:35*/priv; return func() { _cgoCheckPointer(_cgo0, nil); /*line :198:40*/_Cfunc__goboringcrypto_BN_free(_cgo0); }}()()
	}
	// We should not leak bit length of the secret scalar in the key.
	// For this reason, we use BN_bn2binpad instead of BN_bn2bin with fixed length.
	// The fixed length is the order of the large prime subgroup of the curve,
	// returned by EVP_PKEY_get_bits, which is generally the upper bound for
	// generating a private ECDH key.
	bits := func() _Ctype_int{ _cgo0 := /*line :205:46*/pkey; _cgoCheckPointer(_cgo0, nil); return /*line :205:51*/_Cfunc__goboringcrypto_EVP_PKEY_get_bits(_cgo0); }()
	bytes := make([]byte, (bits+7)/8)
	if func() _Ctype_int{ _cgo0 := /*line :207:36*/priv; var _cgo1 *_Ctype_uchar = /*line :207:42*/base(bytes); var _cgo2 _Ctype_int = _Ctype_int /*line :207:60*/(len(bytes)); _cgoCheckPointer(_cgo0, nil); return /*line :207:73*/_Cfunc__goboringcrypto_BN_bn2binpad(_cgo0, _cgo1, _cgo2); }() == 0 {
		return nil, nil, NewOpenSSLError("BN_bn2binpad")
	}
	k = &PrivateKeyECDH{pkey, curve, true}
	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
	return k, bytes, nil
}
