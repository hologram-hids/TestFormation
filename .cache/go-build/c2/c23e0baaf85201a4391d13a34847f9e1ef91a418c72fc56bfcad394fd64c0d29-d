// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/lib/golang/src/vendor/github.com/golang-fips/openssl-fips/openssl/rsa.go:1:1
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && !android && !cmd_go_bootstrap && !msan && !no_openssl && !static
// +build linux,!android,!cmd_go_bootstrap,!msan,!no_openssl,!static

package openssl

// #include "goopenssl.h"
import _ "unsafe"
import (
	"crypto"
	"errors"
	"hash"
	"runtime"
	"strconv"
	"unsafe"
)

func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
		return nil, nil, nil, nil, nil, nil, nil, nil, e
	}

	key := ( /*line :26:9*/_Cfunc__goboringcrypto_RSA_new /*line :26:33*/)()
	if key == nil {
		return bad(NewOpenSSLError("RSA_new failed"))
	}
	defer func() func() { _cgo0 := /*line :30:35*/key; return func() { _cgoCheckPointer(_cgo0, nil); /*line :30:39*/_Cfunc__goboringcrypto_RSA_free(_cgo0); }}()()

	if func() _Ctype_int{ _cgo0 := /*line :32:45*/key; var _cgo1 _Ctype_int = _Ctype_int /*line :32:55*/(bits); var _cgo2 *_Ctype_struct_bn_gencb_st = /*line :32:63*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :32:67*/_Cfunc__goboringcrypto_RSA_generate_key_fips(_cgo0, _cgo1, _cgo2); }() == 0 {
		return bad(NewOpenSSLError("RSA_generate_key_fips failed"))
	}

	var n, e, d, p, q, dp, dq, qinv * /*line :36:35*/_Ctype_GO_BIGNUM /*line :36:46*/
	func() { _cgo0 := /*line :37:33*/key; _cgoBase1 := /*line :37:38*/&n; _cgo1 := _cgoBase1; _cgoBase2 := /*line :37:42*/&e; _cgo2 := _cgoBase2; _cgoBase3 := /*line :37:46*/&d; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); /*line :37:49*/_Cfunc__goboringcrypto_RSA_get0_key(_cgo0, _cgo1, _cgo2, _cgo3); }()
	func() { _cgo0 := /*line :38:37*/key; _cgoBase1 := /*line :38:42*/&p; _cgo1 := _cgoBase1; _cgoBase2 := /*line :38:46*/&q; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); /*line :38:49*/_Cfunc__goboringcrypto_RSA_get0_factors(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :39:40*/key; _cgoBase1 := /*line :39:45*/&dp; _cgo1 := _cgoBase1; _cgoBase2 := /*line :39:50*/&dq; _cgo2 := _cgoBase2; _cgoBase3 := /*line :39:55*/&qinv; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); /*line :39:61*/_Cfunc__goboringcrypto_RSA_get0_crt_params(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return bnToBig(n), bnToBig(e), bnToBig(d), bnToBig(p), bnToBig(q), bnToBig(dp), bnToBig(dq), bnToBig(qinv), nil
}

type PublicKeyRSA struct {
	// _key MUST NOT be accessed directly. Instead, use the withKey method.
	_key * /*line :45:8*/_Ctype_GO_RSA /*line :45:16*/
}

func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
	key := ( /*line :49:9*/_Cfunc__goboringcrypto_RSA_new /*line :49:33*/)()
	if key == nil {
		return nil, NewOpenSSLError("RSA_new failed")
	}
	var n, e * /*line :53:12*/_Ctype_GO_BIGNUM /*line :53:23*/
	n = bigToBN(N)
	e = bigToBN(E)
	func() _Ctype_int{ _cgo0 := /*line :56:33*/key; _cgo1 := /*line :56:38*/n; _cgo2 := /*line :56:41*/e; var _cgo3 *_Ctype_struct_bignum_st = /*line :56:44*/nil; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return /*line :56:48*/_Cfunc__goboringcrypto_RSA_set0_key(_cgo0, _cgo1, _cgo2, _cgo3); }()
	k := &PublicKeyRSA{_key: key}
	runtime.SetFinalizer(k, (*PublicKeyRSA).finalize)
	return k, nil
}

func (k *PublicKeyRSA) finalize() {
	func() { _cgo0 := /*line :63:29*/k._key; _cgoCheckPointer(_cgo0, nil); /*line :63:36*/_Cfunc__goboringcrypto_RSA_free(_cgo0); }()
}

func (k *PublicKeyRSA) withKey(f func(* /*line :66:40*/_Ctype_GO_RSA /*line :66:48*/)  /*line :66:50*/_Ctype_int /*line :66:55*/)  /*line :66:57*/_Ctype_int /*line :66:62*/ {
	// Because of the finalizer, any time _key is passed to cgo, that call must
	// be followed by a call to runtime.KeepAlive, to make sure k is not
	// collected (and finalized) before the cgo call returns.
	defer runtime.KeepAlive(k)
	return f(k._key)
}

type PrivateKeyRSA struct {
	// _key MUST NOT be accessed directly. Instead, use the withKey method.
	_key * /*line :76:8*/_Ctype_GO_RSA /*line :76:16*/
}

func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
	key := ( /*line :80:9*/_Cfunc__goboringcrypto_RSA_new /*line :80:33*/)()
	if key == nil {
		return nil, NewOpenSSLError("RSA_new failed")
	}
	var n, e, d, p, q, dp, dq, qinv * /*line :84:35*/_Ctype_GO_BIGNUM /*line :84:46*/
	n = bigToBN(N)
	e = bigToBN(E)
	d = bigToBN(D)
	func() _Ctype_int{ _cgo0 := /*line :88:33*/key; _cgo1 := /*line :88:38*/n; _cgo2 := /*line :88:41*/e; _cgo3 := /*line :88:44*/d; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :88:46*/_Cfunc__goboringcrypto_RSA_set0_key(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if P != nil && Q != nil {
		p = bigToBN(P)
		q = bigToBN(Q)
		func() _Ctype_int{ _cgo0 := /*line :92:38*/key; _cgo1 := /*line :92:43*/p; _cgo2 := /*line :92:46*/q; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return /*line :92:48*/_Cfunc__goboringcrypto_RSA_set0_factors(_cgo0, _cgo1, _cgo2); }()
	}
	if Dp != nil && Dq != nil && Qinv != nil {
		dp = bigToBN(Dp)
		dq = bigToBN(Dq)
		qinv = bigToBN(Qinv)
		func() _Ctype_int{ _cgo0 := /*line :98:41*/key; _cgo1 := /*line :98:46*/dp; _cgo2 := /*line :98:50*/dq; _cgo3 := /*line :98:54*/qinv; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :98:59*/_Cfunc__goboringcrypto_RSA_set0_crt_params(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}
	k := &PrivateKeyRSA{_key: key}
	runtime.SetFinalizer(k, (*PrivateKeyRSA).finalize)
	return k, nil
}

func (k *PrivateKeyRSA) finalize() {
	func() { _cgo0 := /*line :106:29*/k._key; _cgoCheckPointer(_cgo0, nil); /*line :106:36*/_Cfunc__goboringcrypto_RSA_free(_cgo0); }()
}

func (k *PrivateKeyRSA) withKey(f func(* /*line :109:41*/_Ctype_GO_RSA /*line :109:49*/)  /*line :109:51*/_Ctype_int /*line :109:56*/)  /*line :109:58*/_Ctype_int /*line :109:63*/ {
	// Because of the finalizer, any time _key is passed to cgo, that call must
	// be followed by a call to runtime.KeepAlive, to make sure k is not
	// collected (and finalized) before the cgo call returns.
	defer runtime.KeepAlive(k)
	return f(k._key)
}

func setupRSA(withKey func(func(* /*line :117:34*/_Ctype_GO_RSA /*line :117:42*/)  /*line :117:44*/_Ctype_int /*line :117:49*/)  /*line :117:51*/_Ctype_int /*line :117:56*/,
	padding  /*line :118:10*/_Ctype_int /*line :118:15*/, h hash.Hash, label []byte, saltLen int, ch crypto.Hash,
	init func(* /*line :119:13*/_Ctype_GO_EVP_PKEY_CTX /*line :119:30*/)  /*line :119:32*/_Ctype_int /*line :119:37*/) (pkey * /*line :119:46*/_Ctype_GO_EVP_PKEY /*line :119:59*/, ctx * /*line :119:66*/_Ctype_GO_EVP_PKEY_CTX /*line :119:83*/, err error) {
	defer func() {
		if err != nil {
			if pkey != nil {
				func() { _cgo0 := /*line :123:37*/pkey; _cgoCheckPointer(_cgo0, nil); /*line :123:42*/_Cfunc__goboringcrypto_EVP_PKEY_free(_cgo0); }()
				pkey = nil
			}
			if ctx != nil {
				func() { _cgo0 := /*line :127:41*/ctx; _cgoCheckPointer(_cgo0, nil); /*line :127:45*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_free(_cgo0); }()
				ctx = nil
			}
		}
	}()

	pkey = ( /*line :133:9*/_Cfunc__goboringcrypto_EVP_PKEY_new /*line :133:38*/)()
	if pkey == nil {
		return nil, nil, NewOpenSSLError("EVP_PKEY_new failed")
	}
	if withKey(func(key * /*line :137:23*/_Ctype_GO_RSA /*line :137:31*/)  /*line :137:33*/_Ctype_int /*line :137:38*/ {
		return func() _Ctype_int{ _cgo0 := /*line :138:46*/pkey; _cgo1 := /*line :138:52*/key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :138:56*/_Cfunc__goboringcrypto_EVP_PKEY_set1_RSA(_cgo0, _cgo1); }()
	}) == 0 {
		return nil, nil, fail("EVP_PKEY_set1_RSA")
	}
	ctx = func() *_Ctype_struct_evp_pkey_ctx_st{ _cgo0 := /*line :142:43*/pkey; var _cgo1 *_Ctype_struct_engine_st = /*line :142:49*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :142:53*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_new(_cgo0, _cgo1); }()
	if ctx == nil {
		return nil, nil, NewOpenSSLError("EVP_PKEY_CTX_new failed")
	}
	if init(ctx) == 0 {
		return nil, nil, NewOpenSSLError("EVP_PKEY_operation_init failed")
	}
	if func() _Ctype_int{ _cgo0 := /*line :149:52*/ctx; var _cgo1 _Ctype_int = /*line :149:57*/padding; _cgoCheckPointer(_cgo0, nil); return /*line :149:65*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set_rsa_padding(_cgo0, _cgo1); }() == 0 {
		return nil, nil, NewOpenSSLError("EVP_PKEY_CTX_set_rsa_padding failed")
	}
	if padding == ( /*line :152:16*/_Ciconst_GO_RSA_PKCS1_OAEP_PADDING /*line :152:42*/) {
		md := hashToMD(h)
		if md == nil {
			return nil, nil, errors.New("crypto/rsa: unsupported hash function")
		}
		if func() _Ctype_int{ _cgo0 := /*line :157:53*/ctx; _cgo1 := /*line :157:58*/md; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :157:61*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set_rsa_oaep_md(_cgo0, _cgo1); }() == 0 {
			return nil, nil, NewOpenSSLError("EVP_PKEY_set_rsa_oaep_md failed")
		}
		// ctx takes ownership of label, so malloc a copy for BoringCrypto to free.
		var clabel * /*line :161:15*/_Ctype_uint8_t /*line :161:24*/
		clabel = nil
		// OpenSSL 1.1.1 does not take ownership of the label if the length is zero.
		// Depending on the malloc implementation, if clabel is allocated with malloc(0),
		// metadata for the size-zero allocation is never cleaned up, which is a memory leak.
		// As such, we must only allocate clabel if the label is of non zero length.
		if (len(label) > 0) || (openSSLVersion() > OPENSSL_VERSION_3_0_0) {
			clabel = (* /*line :168:15*/_Ctype_uint8_t /*line :168:24*/)(( /*line :168:26*/_Cfunc__CMalloc /*line :168:33*/)( /*line :168:35*/_Ctype_size_t /*line :168:43*/(len(label))))
			if clabel == nil {
				return nil, nil, fail("OPENSSL_malloc")
			}
			copy((*[1 << 30]byte)(unsafe.Pointer(clabel))[:len(label)], label)
		}
		if func() _Ctype_int{ _cgo0 := /*line :174:57*/ctx; var _cgo1 *_Ctype_uint8_t = /*line :174:62*/clabel; var _cgo2 _Ctype_int = _Ctype_int /*line :174:75*/(len(label)); _cgoCheckPointer(_cgo0, nil); return /*line :174:88*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set0_rsa_oaep_label(_cgo0, _cgo1, _cgo2); }() != 1 {
			if clabel != nil {
				func() { _cgo0 := /*line :176:12*/unsafe.Pointer(clabel); _cgoCheckPointer(_cgo0, nil); /*line :176:35*/_Cfunc_free(_cgo0); }()
			}
			return nil, nil, NewOpenSSLError("EVP_PKEY_CTX_set0_rsa_oaep_label failed")
		}
	}
	if padding == ( /*line :181:16*/_Ciconst_GO_RSA_PKCS1_PSS_PADDING /*line :181:41*/) {
		if saltLen != 0 {
			if func() _Ctype_int{ _cgo0 := /*line :183:58*/ctx; var _cgo1 _Ctype_int = _Ctype_int /*line :183:68*/(saltLen); _cgoCheckPointer(_cgo0, nil); return /*line :183:78*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set_rsa_pss_saltlen(_cgo0, _cgo1); }() == 0 {
				return nil, nil, NewOpenSSLError("EVP_PKEY_set_rsa_pss_saltlen failed")
			}
		}
		md := cryptoHashToMD(ch)
		if md == nil {
			return nil, nil, errors.New("crypto/rsa: unsupported hash function")
		}
		if func() _Ctype_int{ _cgo0 := /*line :191:53*/ctx; _cgo1 := /*line :191:58*/md; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :191:61*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set_rsa_mgf1_md(_cgo0, _cgo1); }() == 0 {
			return nil, nil, NewOpenSSLError("EVP_PKEY_set_rsa_mgf1_md failed")
		}
	}

	return pkey, ctx, nil
}

func cryptRSA(withKey func(func(* /*line :199:34*/_Ctype_GO_RSA /*line :199:42*/)  /*line :199:44*/_Ctype_int /*line :199:49*/)  /*line :199:51*/_Ctype_int /*line :199:56*/,
	padding  /*line :200:10*/_Ctype_int /*line :200:15*/, h hash.Hash, label []byte, saltLen int, ch crypto.Hash,
	init func(* /*line :201:13*/_Ctype_GO_EVP_PKEY_CTX /*line :201:30*/)  /*line :201:32*/_Ctype_int /*line :201:37*/,
	crypt func(* /*line :202:14*/_Ctype_GO_EVP_PKEY_CTX /*line :202:31*/, * /*line :202:34*/_Ctype_uint8_t /*line :202:43*/, * /*line :202:46*/_Ctype_size_t /*line :202:54*/, * /*line :202:57*/_Ctype_uint8_t /*line :202:66*/,  /*line :202:68*/_Ctype_size_t /*line :202:76*/)  /*line :202:78*/_Ctype_int /*line :202:83*/,
	in []byte) ([]byte, error) {

	pkey, ctx, err := setupRSA(withKey, padding, h, label, saltLen, ch, init)
	if err != nil {
		return nil, err
	}
	defer func() func() { _cgo0 := /*line :209:40*/pkey; return func() { _cgoCheckPointer(_cgo0, nil); /*line :209:45*/_Cfunc__goboringcrypto_EVP_PKEY_free(_cgo0); }}()()
	defer func() func() { _cgo0 := /*line :210:44*/ctx; return func() { _cgoCheckPointer(_cgo0, nil); /*line :210:48*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_free(_cgo0); }}()()

	var outLen  /*line :212:13*/_Ctype_size_t /*line :212:21*/
	if crypt(ctx, nil, &outLen, base(in),  /*line :213:40*/_Ctype_size_t /*line :213:48*/(len(in))) == 0 {
		return nil, NewOpenSSLError("EVP_PKEY_decrypt/encrypt failed")
	}
	out := make([]byte, outLen)
	if crypt(ctx, base(out), &outLen, base(in),  /*line :217:46*/_Ctype_size_t /*line :217:54*/(len(in))) <= 0 {
		return nil, NewOpenSSLError("EVP_PKEY_decrypt/encrypt failed")
	}
	return out[:outLen], nil
}

func DecryptRSAOAEP(h hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
	return cryptRSA(priv.withKey, ( /*line :224:32*/_Ciconst_GO_RSA_PKCS1_OAEP_PADDING /*line :224:58*/), h, label, 0, 0, decryptInit, decrypt, ciphertext)
}

func EncryptRSAOAEP(h hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
	return cryptRSA(pub.withKey, ( /*line :228:31*/_Ciconst_GO_RSA_PKCS1_OAEP_PADDING /*line :228:57*/), h, label, 0, 0, encryptInit, encrypt, msg)
}

func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
	return cryptRSA(priv.withKey, ( /*line :232:32*/_Ciconst_GO_RSA_PKCS1_PADDING /*line :232:53*/), nil, nil, 0, 0, decryptInit, decrypt, ciphertext)
}

func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
	return cryptRSA(pub.withKey, ( /*line :236:31*/_Ciconst_GO_RSA_PKCS1_PADDING /*line :236:52*/), nil, nil, 0, 0, encryptInit, encrypt, msg)
}

func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
	return cryptRSA(priv.withKey, ( /*line :240:32*/_Ciconst_GO_RSA_NO_PADDING /*line :240:50*/), nil, nil, 0, 0, decryptInit, decrypt, ciphertext)
}

func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
	return cryptRSA(pub.withKey, ( /*line :244:31*/_Ciconst_GO_RSA_NO_PADDING /*line :244:49*/), nil, nil, 0, 0, encryptInit, encrypt, msg)
}

// These dumb wrappers work around the fact that cgo functions cannot be used as values directly.

func decryptInit(ctx * /*line :249:23*/_Ctype_GO_EVP_PKEY_CTX /*line :249:40*/)  /*line :249:42*/_Ctype_int /*line :249:47*/ {
	return func() _Ctype_int{ _cgo0 := /*line :250:49*/ctx; _cgoCheckPointer(_cgo0, nil); return /*line :250:53*/_Cfunc__goboringcrypto_EVP_PKEY_decrypt_init(_cgo0); }()
}

func decrypt(ctx * /*line :253:19*/_Ctype_GO_EVP_PKEY_CTX /*line :253:36*/, out * /*line :253:43*/_Ctype_uint8_t /*line :253:52*/, outLen * /*line :253:62*/_Ctype_size_t /*line :253:70*/, in * /*line :253:76*/_Ctype_uint8_t /*line :253:85*/, inLen  /*line :253:93*/_Ctype_size_t /*line :253:101*/)  /*line :253:103*/_Ctype_int /*line :253:108*/ {
	return func() _Ctype_int{ _cgo0 := /*line :254:44*/ctx; var _cgo1 *_Ctype_uint8_t = /*line :254:49*/out; var _cgo2 *_Ctype_size_t = /*line :254:54*/outLen; var _cgo3 *_Ctype_uint8_t = /*line :254:62*/in; var _cgo4 _Ctype_size_t = /*line :254:66*/inLen; _cgoCheckPointer(_cgo0, nil); return /*line :254:72*/_Cfunc__goboringcrypto_EVP_PKEY_decrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
}

func encryptInit(ctx * /*line :257:23*/_Ctype_GO_EVP_PKEY_CTX /*line :257:40*/)  /*line :257:42*/_Ctype_int /*line :257:47*/ {
	return func() _Ctype_int{ _cgo0 := /*line :258:49*/ctx; _cgoCheckPointer(_cgo0, nil); return /*line :258:53*/_Cfunc__goboringcrypto_EVP_PKEY_encrypt_init(_cgo0); }()
}

func encrypt(ctx * /*line :261:19*/_Ctype_GO_EVP_PKEY_CTX /*line :261:36*/, out * /*line :261:43*/_Ctype_uint8_t /*line :261:52*/, outLen * /*line :261:62*/_Ctype_size_t /*line :261:70*/, in * /*line :261:76*/_Ctype_uint8_t /*line :261:85*/, inLen  /*line :261:93*/_Ctype_size_t /*line :261:101*/)  /*line :261:103*/_Ctype_int /*line :261:108*/ {
	return func() _Ctype_int{ _cgo0 := /*line :262:44*/ctx; var _cgo1 *_Ctype_uint8_t = /*line :262:49*/out; var _cgo2 *_Ctype_size_t = /*line :262:54*/outLen; var _cgo3 *_Ctype_uint8_t = /*line :262:62*/in; var _cgo4 _Ctype_size_t = /*line :262:66*/inLen; _cgoCheckPointer(_cgo0, nil); return /*line :262:72*/_Cfunc__goboringcrypto_EVP_PKEY_encrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
}

// These should match crypto/rsa/pss.go
const saltLengthAuto = 0
const saltLengthEqualsHash = -1

var invalidSaltLenErr = errors.New("crypto/rsa: PSSOptions.SaltLength cannot be negative")

func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
	md := cryptoHashToMD(h)
	if md == nil {
		return nil, errors.New("crypto/rsa: unsupported hash function")
	}
	switch saltLen {
	case saltLengthAuto:
		saltLen = ( /*line :278:13*/_Ciconst_GO_RSA_PSS_SALTLEN_AUTO /*line :278:37*/)
	case saltLengthEqualsHash:
		saltLen = ( /*line :280:13*/_Ciconst_GO_RSA_PSS_SALTLEN_DIGEST /*line :280:39*/)
	default:
		// If we get here saltLen is either > 0 or < -1, in the
		// latter case we fail out.
		if saltLen <= 0 {
			return nil, invalidSaltLenErr
		}
	}
	var out []byte
	var outLen  /*line :289:13*/_Ctype_uint /*line :289:19*/
	if priv.withKey(func(key * /*line :290:28*/_Ctype_GO_RSA /*line :290:36*/)  /*line :290:38*/_Ctype_int /*line :290:43*/ {
		out = make([]byte, func() _Ctype_uint{ _cgo0 := /*line :291:49*/key; _cgoCheckPointer(_cgo0, nil); return /*line :291:53*/_Cfunc__goboringcrypto_RSA_size(_cgo0); }())
		return func() _Ctype_int{ _cgo0 := /*line :292:46*/key; var _cgo1 *_Ctype_uint = /*line :292:51*/&outLen; var _cgo2 *_Ctype_uint8_t = /*line :292:60*/base(out); var _cgo3 _Ctype_uint = _Ctype_uint /*line :292:77*/(len(out)); var _cgo4 *_Ctype_uint8_t = /*line :293:4*/base(hashed); var _cgo5 _Ctype_uint = _Ctype_uint /*line :293:24*/(len(hashed)); _cgo6 := /*line :293:39*/md; var _cgo7 *_Ctype_struct_env_md_st = /*line :293:43*/nil; var _cgo8 _Ctype_int = _Ctype_int /*line :293:53*/(saltLen); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo6, nil); return /*line :293:63*/_Cfunc__goboringcrypto_RSA_sign_pss_mgf1(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8); }()
	}) == 0 {
		return nil, fail("RSA_sign_pss_mgf1")
	}

	return out[:outLen], nil
}

func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
	md := cryptoHashToMD(h)
	if md == nil {
		return errors.New("crypto/rsa: unsupported hash function")
	}
	switch saltLen {
	case saltLengthAuto:
		saltLen = ( /*line :308:13*/_Ciconst_GO_RSA_PSS_SALTLEN_AUTO /*line :308:37*/)
	case saltLengthEqualsHash:
		saltLen = ( /*line :310:13*/_Ciconst_GO_RSA_PSS_SALTLEN_DIGEST /*line :310:39*/)
	default:
		// If we get here saltLen is either > 0 or < -1, in the
		// latter case we fail out.
		if saltLen <= 0 {
			return invalidSaltLenErr
		}
	}
	if pub.withKey(func(key * /*line :318:27*/_Ctype_GO_RSA /*line :318:35*/)  /*line :318:37*/_Ctype_int /*line :318:42*/ {
		return func() _Ctype_int{ _cgo0 := /*line :319:48*/key; var _cgo1 *_Ctype_uint8_t = /*line :319:53*/base(hashed); var _cgo2 _Ctype_uint = _Ctype_uint /*line :319:73*/(len(hashed)); _cgo3 := /*line :320:4*/md; var _cgo4 *_Ctype_struct_env_md_st = /*line :320:8*/nil; var _cgo5 _Ctype_int = _Ctype_int /*line :320:18*/(saltLen); var _cgo6 *_Ctype_uint8_t = /*line :320:29*/base(sig); var _cgo7 _Ctype_uint = _Ctype_uint /*line :320:46*/(len(sig)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); return /*line :320:57*/_Cfunc__goboringcrypto_RSA_verify_pss_mgf1(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
	}) == 0 {
		return fail("RSA_verify_pss_mgf1")
	}
	return nil
}

func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, msg []byte, msgIsHashed bool) ([]byte, error) {
	if h == 0 && ExecutingTest() {
		return signRSAPKCS1v15Raw(priv, msg, ( /*line :329:40*/_Cfunc__goboringcrypto_EVP_md_null /*line :329:68*/)())
	}

	md := cryptoHashToMD(h)
	if md == nil {
		return nil, errors.New("crypto/rsa: unsupported hash function: " + strconv.Itoa(int(h)))
	}

	if msgIsHashed {
		var out []byte
		var outLen  /*line :339:14*/_Ctype_uint /*line :339:20*/
		PanicIfStrictFIPS("You must provide a raw unhashed message for PKCS1v15 signing and use HashSignPKCS1v15 instead of SignPKCS1v15")
		nid := func() _Ctype_int{ _cgo0 := /*line :341:40*/md; _cgoCheckPointer(_cgo0, nil); return /*line :341:43*/_Cfunc__goboringcrypto_EVP_MD_type(_cgo0); }()
		if priv.withKey(func(key * /*line :342:29*/_Ctype_GO_RSA /*line :342:37*/)  /*line :342:39*/_Ctype_int /*line :342:44*/ {
			out = make([]byte, func() _Ctype_uint{ _cgo0 := /*line :343:50*/key; _cgoCheckPointer(_cgo0, nil); return /*line :343:54*/_Cfunc__goboringcrypto_RSA_size(_cgo0); }())
			return func() _Ctype_int{ var _cgo0 _Ctype_int = /*line :344:38*/nid; var _cgo1 *_Ctype_uint8_t = /*line :344:43*/base(msg); var _cgo2 _Ctype_uint = _Ctype_uint /*line :344:60*/(len(msg)); var _cgo3 *_Ctype_uint8_t = /*line :344:72*/base(out); var _cgo4 *_Ctype_uint = /*line :344:83*/&outLen; _cgo5 := /*line :344:92*/key; _cgoCheckPointer(_cgo5, nil); return /*line :344:96*/_Cfunc__goboringcrypto_RSA_sign(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
		}) == 0 {
			return nil, NewOpenSSLError("RSA_sign")
		}
		runtime.KeepAlive(priv)
		return out[:outLen], nil
	}

	var out []byte
	var outLen  /*line :353:13*/_Ctype_size_t /*line :353:21*/

	if priv.withKey(func(key * /*line :355:28*/_Ctype_GO_RSA /*line :355:36*/)  /*line :355:38*/_Ctype_int /*line :355:43*/ {
		return func() _Ctype_int{ _cgo0 := /*line :356:41*/md; var _cgo1 *_Ctype_uint8_t = /*line :356:45*/base(msg); var _cgo2 _Ctype_uint = _Ctype_uint /*line :356:62*/(len(msg)); var _cgo3 *_Ctype_uint8_t = /*line :356:74*/base(out); var _cgo4 *_Ctype_size_t = /*line :356:85*/&outLen; _cgo5 := /*line :356:94*/key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo5, nil); return /*line :356:98*/_Cfunc__goboringcrypto_EVP_RSA_sign(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	}) == 0 {
		return nil, NewOpenSSLError("RSA_sign")
	}
	return out[:outLen], nil
}

func signRSAPKCS1v15Raw(priv *PrivateKeyRSA, msg []byte, md * /*line :363:62*/_Ctype_GO_EVP_MD /*line :363:73*/) ([]byte, error) {
	var out []byte
	var outLen  /*line :365:13*/_Ctype_size_t /*line :365:21*/
	PanicIfStrictFIPS("You must provide a raw unhashed message for PKCS1v15 signing and use HashSignPKCS1v15 instead of SignPKCS1v15")

	if priv.withKey(func(key * /*line :368:28*/_Ctype_GO_RSA /*line :368:36*/)  /*line :368:38*/_Ctype_int /*line :368:43*/ {
		out = make([]byte, func() _Ctype_uint{ _cgo0 := /*line :369:49*/key; _cgoCheckPointer(_cgo0, nil); return /*line :369:53*/_Cfunc__goboringcrypto_RSA_size(_cgo0); }())
		outLen =  /*line :370:12*/_Ctype_size_t /*line :370:20*/(len(out))
		return func() _Ctype_int{ _cgo0 := /*line :371:41*/md; var _cgo1 *_Ctype_struct_evp_pkey_ctx_st = /*line :371:45*/nil; var _cgo2 *_Ctype_uint8_t = /*line :371:50*/base(msg); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :372:12*/(len(msg)); var _cgo4 *_Ctype_uint8_t = /*line :372:24*/base(out); var _cgo5 *_Ctype_size_t = /*line :372:35*/&outLen; _cgo6 := /*line :372:44*/key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo6, nil); return /*line :372:48*/_Cfunc__goboringcrypto_EVP_sign_raw(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	}) == 0 {
		return nil, NewOpenSSLError("RSA_sign")
	}
	runtime.KeepAlive(priv)
	return out[:outLen], nil
}

func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, msg, sig []byte, msgIsHashed bool) error {
	if h == 0 && ExecutingTest() {
		return verifyRSAPKCS1v15Raw(pub, msg, sig)
	}

	md := cryptoHashToMD(h)
	if md == nil {
		return errors.New("crypto/rsa: unsupported hash function")
	}

	if pub.withKey(func(key * /*line :390:27*/_Ctype_GO_RSA /*line :390:35*/)  /*line :390:37*/_Ctype_int /*line :390:42*/ {
		size := int(func() _Ctype_uint{ _cgo0 := /*line :391:42*/key; _cgoCheckPointer(_cgo0, nil); return /*line :391:46*/_Cfunc__goboringcrypto_RSA_size(_cgo0); }())
		if len(sig) < size {
			return 0
		}
		return 1
	}) == 0 {
		return errors.New("crypto/rsa: verification error")
	}

	if msgIsHashed {
		PanicIfStrictFIPS("You must provide a raw unhashed message for PKCS1v15 verification and use HashVerifyPKCS1v15 instead of VerifyPKCS1v15")
		nid := func() _Ctype_int{ _cgo0 := /*line :402:40*/md; _cgoCheckPointer(_cgo0, nil); return /*line :402:43*/_Cfunc__goboringcrypto_EVP_MD_type(_cgo0); }()
		if pub.withKey(func(key * /*line :403:28*/_Ctype_GO_RSA /*line :403:36*/)  /*line :403:38*/_Ctype_int /*line :403:43*/ {
			return func() _Ctype_int{ var _cgo0 _Ctype_int = /*line :404:40*/nid; var _cgo1 *_Ctype_uint8_t = /*line :404:45*/base(msg); var _cgo2 _Ctype_uint = _Ctype_uint /*line :404:62*/(len(msg)); var _cgo3 *_Ctype_uint8_t = /*line :404:74*/base(sig); var _cgo4 _Ctype_uint = _Ctype_uint /*line :404:91*/(len(sig)); _cgo5 := /*line :404:103*/key; _cgoCheckPointer(_cgo5, nil); return /*line :404:107*/_Cfunc__goboringcrypto_RSA_verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
		}) == 0 {
			return NewOpenSSLError("RSA_verify failed")
		}
		return nil
	}

	if pub.withKey(func(key * /*line :411:27*/_Ctype_GO_RSA /*line :411:35*/)  /*line :411:37*/_Ctype_int /*line :411:42*/ {
		return func() _Ctype_int{ _cgo0 := /*line :412:43*/md; var _cgo1 *_Ctype_uint8_t = /*line :412:47*/base(msg); var _cgo2 _Ctype_uint = _Ctype_uint /*line :412:64*/(len(msg)); var _cgo3 *_Ctype_uint8_t = /*line :412:76*/base(sig); var _cgo4 _Ctype_uint = _Ctype_uint /*line :412:93*/(len(sig)); _cgo5 := /*line :412:105*/key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo5, nil); return /*line :412:109*/_Cfunc__goboringcrypto_EVP_RSA_verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	}) == 0 {
		return NewOpenSSLError("RSA_verify failed")
	}
	return nil
}

func verifyRSAPKCS1v15Raw(pub *PublicKeyRSA, msg, sig []byte) error {
	if pub.withKey(func(key * /*line :420:27*/_Ctype_GO_RSA /*line :420:35*/)  /*line :420:37*/_Ctype_int /*line :420:42*/ {
		size := int(func() _Ctype_uint{ _cgo0 := /*line :421:42*/key; _cgoCheckPointer(_cgo0, nil); return /*line :421:46*/_Cfunc__goboringcrypto_RSA_size(_cgo0); }())
		if len(sig) < size {
			return 0
		}
		return 1
	}) == 0 {
		return errors.New("crypto/rsa: verification error")
	}
	if pub.withKey(func(key * /*line :429:27*/_Ctype_GO_RSA /*line :429:35*/)  /*line :429:37*/_Ctype_int /*line :429:42*/ {
		return func() _Ctype_int{ var _cgo0 *_Ctype_uint8_t = /*line :430:43*/base(msg); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :430:62*/(len(msg)); var _cgo2 *_Ctype_uint8_t = /*line :430:74*/base(sig); var _cgo3 _Ctype_uint = _Ctype_uint /*line :430:91*/(len(sig)); _cgo4 := /*line :430:103*/key; _cgoCheckPointer(_cgo4, nil); return /*line :430:107*/_Cfunc__goboringcrypto_EVP_verify_raw(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	}) == 0 {
		return NewOpenSSLError("RSA_verify failed")
	}
	return nil
}
