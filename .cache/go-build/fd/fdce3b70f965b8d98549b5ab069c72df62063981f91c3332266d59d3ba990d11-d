// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/lib/golang/src/vendor/github.com/golang-fips/openssl-fips/openssl/hkdf.go:1:1
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && !android && !cmd_go_bootstrap && !msan && !no_openssl && !static
// +build linux,!android,!cmd_go_bootstrap,!msan,!no_openssl,!static

package openssl

// #include "goopenssl.h"
import _ "unsafe"
import (
	"hash"
	"io"
	"runtime"
)

type hkdf struct {
	ctx * /*line :19:7*/_Ctype_GO_EVP_PKEY_CTX /*line :19:24*/
}

func SupportsHKDF() bool {
	return openSSLVersion() >= OPENSSL_VERSION_1_1_1
}

func newHKDF(h func() hash.Hash, mode  /*line :26:39*/_Ctype_int /*line :26:44*/) (*hkdf, error) {
	if openSSLVersion() < OPENSSL_VERSION_1_1_1 {
		return nil, NewOpenSSLError("HKDF is not supported")
	}

	ch := h()
	md := hashToMD(ch)
	if md == nil {
		return nil, NewOpenSSLError("Unknown hash algorithm")
	}

	ctx := ( /*line :37:9*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_new_id /*line :37:45*/)(( /*line :37:47*/_Ciconst_GO_EVP_PKEY_HKDF /*line :37:64*/), nil)
	if ctx == nil {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_new_id failed")
	}
	c := &hkdf{ctx: ctx}
	runtime.SetFinalizer(c, (*hkdf).finalize)
	defer runtime.KeepAlive(c)

	if func() _Ctype_int{ _cgo0 := /*line :45:44*/ctx; _cgoCheckPointer(_cgo0, nil); return /*line :45:48*/_Cfunc__goboringcrypto_EVP_PKEY_derive_init(_cgo0); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_derive_init failed")
	}
	if func() _Ctype_int{ _cgo0 := /*line :48:50*/ctx; var _cgo1 _Ctype_int = /*line :48:55*/mode; _cgoCheckPointer(_cgo0, nil); return /*line :48:60*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set_hkdf_mode(_cgo0, _cgo1); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_set_hkdf_mode failed")
	}
	if func() _Ctype_int{ _cgo0 := /*line :51:48*/ctx; _cgo1 := /*line :51:53*/md; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :51:56*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set_hkdf_md(_cgo0, _cgo1); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_set_hkdf_md failed")
	}

	return c, nil
}

func (c *hkdf) finalize() {
	if c.ctx != nil {
		func() { _cgo0 := /*line :60:39*/c.ctx; _cgoCheckPointer(_cgo0, nil); /*line :60:45*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_free(_cgo0); }()
	}
}

func (c *hkdf) Read(p []byte) (int, error) {
	defer runtime.KeepAlive(c)

	outLen :=  /*line :67:12*/_Ctype_size_t /*line :67:20*/(len(p))
	if func() _Ctype_int{ _cgo0 := /*line :68:39*/c.ctx; var _cgo1 *_Ctype_uchar = /*line :68:46*/base(p); var _cgo2 *_Ctype_size_t = /*line :68:55*/&outLen; _cgoCheckPointer(_cgo0, nil); return /*line :68:63*/_Cfunc__goboringcrypto_EVP_PKEY_derive(_cgo0, _cgo1, _cgo2); }() != 1 {
		return 0, NewOpenSSLError("EVP_PKEY_derive failed")
	}
	return int(outLen), nil
}

func ExtractHKDF(h func() hash.Hash, secret, salt []byte) ([]byte, error) {
	c, err := newHKDF(h, ( /*line :75:23*/_Ciconst_GO_EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY /*line :75:59*/))
	if err != nil {
		return nil, err
	}
	if func() _Ctype_int{ _cgo0 := /*line :79:50*/c.ctx; var _cgo1 *_Ctype_uchar = /*line :79:57*/base(secret); var _cgo2 _Ctype_int = _Ctype_int /*line :79:76*/(len(secret)); _cgoCheckPointer(_cgo0, nil); return /*line :79:90*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set1_hkdf_key(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_set1_hkdf_key failed")
	}
	if func() _Ctype_int{ _cgo0 := /*line :82:51*/c.ctx; var _cgo1 *_Ctype_uchar = /*line :82:58*/base(salt); var _cgo2 _Ctype_int = _Ctype_int /*line :82:75*/(len(salt)); _cgoCheckPointer(_cgo0, nil); return /*line :82:87*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set1_hkdf_salt(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_set1_hkdf_salt failed")
	}
	var outLen  /*line :85:13*/_Ctype_size_t /*line :85:21*/
	if func() _Ctype_int{ _cgo0 := /*line :86:39*/c.ctx; var _cgo1 *_Ctype_uchar = /*line :86:46*/nil; var _cgo2 *_Ctype_size_t = /*line :86:51*/&outLen; _cgoCheckPointer(_cgo0, nil); return /*line :86:59*/_Cfunc__goboringcrypto_EVP_PKEY_derive(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_derive_init failed")
	}
	out := make([]byte, outLen)
	if func() _Ctype_int{ _cgo0 := /*line :90:39*/c.ctx; var _cgo1 *_Ctype_uchar = /*line :90:46*/base(out); var _cgo2 *_Ctype_size_t = /*line :90:57*/&outLen; _cgoCheckPointer(_cgo0, nil); return /*line :90:65*/_Cfunc__goboringcrypto_EVP_PKEY_derive(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_derive failed")
	}
	return out[:outLen], nil
}

func ExpandHKDF(h func() hash.Hash, pseudorandomKey, info []byte) (io.Reader, error) {
	c, err := newHKDF(h, ( /*line :97:23*/_Ciconst_GO_EVP_PKEY_HKDEF_MODE_EXPAND_ONLY /*line :97:58*/))
	if err != nil {
		return nil, err
	}
	if func() _Ctype_int{ _cgo0 := /*line :101:50*/c.ctx; var _cgo1 *_Ctype_uchar = /*line :101:57*/base(pseudorandomKey); var _cgo2 _Ctype_int = _Ctype_int /*line :101:85*/(len(pseudorandomKey)); _cgoCheckPointer(_cgo0, nil); return /*line :101:108*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_set1_hkdf_key(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_set1_hkdf_key failed")
	}
	if func() _Ctype_int{ _cgo0 := /*line :104:51*/c.ctx; var _cgo1 *_Ctype_uchar = /*line :104:58*/base(info); var _cgo2 _Ctype_int = _Ctype_int /*line :104:75*/(len(info)); _cgoCheckPointer(_cgo0, nil); return /*line :104:87*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_add1_hkdf_info(_cgo0, _cgo1, _cgo2); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_add1_hkdf_info failed")
	}
	return c, nil
}
