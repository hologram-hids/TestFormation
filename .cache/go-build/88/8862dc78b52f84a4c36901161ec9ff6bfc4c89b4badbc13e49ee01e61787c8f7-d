// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/lib/golang/src/vendor/github.com/golang-fips/openssl-fips/openssl/aes.go:1:1
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && !android && !cmd_go_bootstrap && !msan && !no_openssl && !static
// +build linux,!android,!cmd_go_bootstrap,!msan,!no_openssl,!static

package openssl

// #include "goopenssl.h"
import _ "unsafe"
import (
	"crypto/cipher"
	"errors"
	"runtime"
	"strconv"
	"unsafe"
)

type aesKeySizeError int

func (k aesKeySizeError) Error() string {
	return "crypto/aes: invalid key size " + strconv.Itoa(int(k))
}

const aesBlockSize = 16

type aesCipher struct {
	key     []byte
	enc_ctx * /*line :30:11*/_Ctype_EVP_CIPHER_CTX /*line :30:27*/
	dec_ctx * /*line :31:11*/_Ctype_EVP_CIPHER_CTX /*line :31:27*/
	cipher  * /*line :32:11*/_Ctype_EVP_CIPHER /*line :32:23*/
}

type extraModes interface {
	// Copied out of crypto/aes/modes.go.
	NewCBCEncrypter(iv []byte) cipher.BlockMode
	NewCBCDecrypter(iv []byte) cipher.BlockMode
	NewCTR(iv []byte) cipher.Stream
	NewGCM(nonceSize, tagSize int) (cipher.AEAD, error)

	// Invented for BoringCrypto.
	NewGCMTLS() (cipher.AEAD, error)
}

var _ extraModes = (*aesCipher)(nil)

func NewAESCipher(key []byte) (cipher.Block, error) {
	c := &aesCipher{key: make([]byte, len(key))}
	copy(c.key, key)

	switch len(c.key) * 8 {
	case 128:
		c.cipher = ( /*line :54:14*/_Cfunc__goboringcrypto_EVP_aes_128_ecb /*line :54:46*/)()
	case 192:
		c.cipher = ( /*line :56:14*/_Cfunc__goboringcrypto_EVP_aes_192_ecb /*line :56:46*/)()
	case 256:
		c.cipher = ( /*line :58:14*/_Cfunc__goboringcrypto_EVP_aes_256_ecb /*line :58:46*/)()
	default:
		return nil, errors.New("crypto/cipher: Invalid key size")
	}

	runtime.SetFinalizer(c, (*aesCipher).finalize)

	return c, nil
}

func (c *aesCipher) finalize() {
	if c.enc_ctx != nil {
		func() { _cgo0 := /*line :70:41*/c.enc_ctx; _cgoCheckPointer(_cgo0, nil); /*line :70:51*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_free(_cgo0); }()
	}
	if c.dec_ctx != nil {
		func() { _cgo0 := /*line :73:41*/c.dec_ctx; _cgoCheckPointer(_cgo0, nil); /*line :73:51*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_free(_cgo0); }()
	}
}

func (c *aesCipher) BlockSize() int { return aesBlockSize }

func (c *aesCipher) Encrypt(dst, src []byte) {
	if inexactOverlap(dst, src) {
		panic("crypto/cipher: invalid buffer overlap")
	}
	if len(src) < aesBlockSize {
		panic("crypto/aes: input not full block")
	}
	if len(dst) < aesBlockSize {
		panic("crypto/aes: output not full block")
	}

	if c.enc_ctx == nil {
		c.enc_ctx = ( /*line :91:15*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_new /*line :91:50*/)()
		if c.enc_ctx == nil {
			panic("cipher: unable to create EVP cipher ctx")
		}

		k := (* /*line :96:10*/_Ctype_uchar /*line :96:17*/)(unsafe.Pointer(&c.key[0]))

		if  /*line :98:6*/_Ctype_int /*line :98:11*/(1) != func() _Ctype_int{ _cgo0 := /*line :98:54*/c.enc_ctx; _cgo1 := /*line :98:65*/c.cipher; var _cgo2 *_Ctype_struct_engine_st = /*line :98:75*/nil; var _cgo3 *_Ctype_uchar = /*line :98:80*/k; var _cgo4 *_Ctype_uchar = /*line :98:83*/nil; var _cgo5 _Ctype_int = /*line :98:88*/_Ciconst_GO_AES_ENCRYPT /*line :98:104*/; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :98:105*/_Cfunc__goboringcrypto_EVP_CipherInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() {
			panic("cipher: unable to initialize EVP cipher ctx")
		}
	}

	outlen :=  /*line :103:12*/_Ctype_int /*line :103:17*/(0)
	func() _Ctype_int{ _cgo0 := /*line :104:37*/c.enc_ctx; var _cgo1 *_Ctype_uchar = /*line :104:48*/(*_Ctype_uchar /*line :104:57*/)(unsafe.Pointer(&dst[0])); var _cgo2 *_Ctype_int = /*line :104:85*/&outlen; var _cgo3 *_Ctype_uchar = /*line :104:94*/(*_Ctype_uchar /*line :104:103*/)(unsafe.Pointer(&src[0])); var _cgo4 _Ctype_int = _Ctype_int /*line :104:136*/(aesBlockSize); _cgoCheckPointer(_cgo0, nil); return /*line :104:151*/_Cfunc__goboringcrypto_EVP_CipherUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(c)
}

func (c *aesCipher) Decrypt(dst, src []byte) {
	if inexactOverlap(dst, src) {
		panic("crypto/cipher: invalid buffer overlap")
	}
	if len(src) < aesBlockSize {
		panic("crypto/aes: input not full block")
	}
	if len(dst) < aesBlockSize {
		panic("crypto/aes: output not full block")
	}
	if c.dec_ctx == nil {
		c.dec_ctx = ( /*line :119:15*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_new /*line :119:50*/)()
		if c.dec_ctx == nil {
			panic("cipher: unable to create EVP cipher ctx")
		}

		k := (* /*line :124:10*/_Ctype_uchar /*line :124:17*/)(unsafe.Pointer(&c.key[0]))

		if  /*line :126:6*/_Ctype_int /*line :126:11*/(1) != func() _Ctype_int{ _cgo0 := /*line :126:54*/c.dec_ctx; _cgo1 := /*line :126:65*/c.cipher; var _cgo2 *_Ctype_struct_engine_st = /*line :126:75*/nil; var _cgo3 *_Ctype_uchar = /*line :126:80*/k; var _cgo4 *_Ctype_uchar = /*line :126:83*/nil; var _cgo5 _Ctype_int = /*line :126:88*/_Ciconst_GO_AES_DECRYPT /*line :126:104*/; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :126:105*/_Cfunc__goboringcrypto_EVP_CipherInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() {
			panic("cipher: unable to initialize EVP cipher ctx")
		}
	}
	// Workaround - padding detection is broken but we don't need it
	// since we check for full blocks
	if func() _Ctype_int{ _cgo0 := /*line :132:50*/c.dec_ctx; var _cgo1 _Ctype_int = /*line :132:61*/0; _cgoCheckPointer(_cgo0, nil); return /*line :132:63*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_set_padding(_cgo0, _cgo1); }() != 1 {
		panic("crypto/cipher: could not disable cipher padding")
	}
	outlen :=  /*line :135:12*/_Ctype_int /*line :135:17*/(0)
	func() _Ctype_int{ _cgo0 := /*line :136:37*/c.dec_ctx; var _cgo1 *_Ctype_uchar = /*line :136:48*/(*_Ctype_uchar /*line :136:57*/)(unsafe.Pointer(&dst[0])); var _cgo2 *_Ctype_int = /*line :136:85*/&outlen; var _cgo3 *_Ctype_uchar = /*line :136:94*/(*_Ctype_uchar /*line :136:103*/)(unsafe.Pointer(&src[0])); var _cgo4 _Ctype_int = _Ctype_int /*line :136:136*/(aesBlockSize); _cgoCheckPointer(_cgo0, nil); return /*line :136:151*/_Cfunc__goboringcrypto_EVP_CipherUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(c)
}

type aesCBC struct {
	key  []byte
	mode  /*line :142:7*/_Ctype_int /*line :142:12*/
	iv   [aesBlockSize]byte
	ctx  * /*line :144:8*/_Ctype_EVP_CIPHER_CTX /*line :144:24*/
}

func (x *aesCBC) BlockSize() int { return aesBlockSize }

func (x *aesCBC) CryptBlocks(dst, src []byte) {
	if inexactOverlap(dst, src) {
		panic("crypto/cipher: invalid buffer overlap")
	}
	if len(src)%aesBlockSize != 0 {
		panic("crypto/cipher: input not full blocks")
	}
	if len(dst) < len(src) {
		panic("crypto/cipher: output smaller than input")
	}
	if len(src) > 0 {
		outlen :=  /*line :160:13*/_Ctype_int /*line :160:18*/(0)
		// Workaround - padding detection is broken but we don't need it
		// since we check for full blocks
		if func() _Ctype_int{ _cgo0 := /*line :163:51*/x.ctx; var _cgo1 _Ctype_int = /*line :163:58*/0; _cgoCheckPointer(_cgo0, nil); return /*line :163:60*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_set_padding(_cgo0, _cgo1); }() != 1 {
			panic("crypto/cipher: could not disable cipher padding")
		}
		if func() _Ctype_int{ _cgo0 := /*line :167:4*/x.ctx; var _cgo1 *_Ctype_uchar = /*line :168:4*/base(dst); var _cgo2 *_Ctype_int = /*line :168:15*/&outlen; var _cgo3 *_Ctype_uchar = /*line :169:4*/base(src); var _cgo4 _Ctype_int = _Ctype_int /*line :169:20*/(len(src)); _cgoCheckPointer(_cgo0, nil); return /*line :170:4*/_Cfunc__goboringcrypto_EVP_CipherUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() != 1 {
			panic("crypto/cipher: CipherUpdate failed")
		}
		runtime.KeepAlive(x)
	}
}

func (x *aesCBC) SetIV(iv []byte) {
	if len(iv) != aesBlockSize {
		panic("cipher: incorrect length IV")
	}
	copy(x.iv[:], iv)
	if  /*line :182:5*/_Ctype_int /*line :182:10*/(1) != func() _Ctype_int{ _cgo0 := /*line :182:53*/x.ctx; var _cgo1 *_Ctype_struct_evp_cipher_st = /*line :182:60*/nil; var _cgo2 *_Ctype_struct_engine_st = /*line :182:65*/nil; var _cgo3 *_Ctype_uchar = /*line :182:70*/nil; var _cgo4 *_Ctype_uchar = /*line :182:75*/(*_Ctype_uchar /*line :182:84*/)(unsafe.Pointer(&x.iv[0])); var _cgo5 _Ctype_int = /*line :182:113*/-1; _cgoCheckPointer(_cgo0, nil); return /*line :182:116*/_Cfunc__goboringcrypto_EVP_CipherInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() {
		panic("cipher: unable to initialize EVP cipher ctx")
	}
}

func (c *aesCipher) NewCBCEncrypter(iv []byte) cipher.BlockMode {
	x := &aesCBC{key: c.key, mode: ( /*line :188:33*/_Ciconst_GO_AES_ENCRYPT /*line :188:48*/)}
	copy(x.iv[:], iv)

	x.ctx = ( /*line :191:10*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_new /*line :191:45*/)()
	if x.ctx == nil {
		panic("cipher: unable to create EVP cipher ctx")
	}

	k := (* /*line :196:9*/_Ctype_uchar /*line :196:16*/)(unsafe.Pointer(&x.key[0]))
	vec := (* /*line :197:11*/_Ctype_uchar /*line :197:18*/)(unsafe.Pointer(&x.iv[0]))

	var cipher * /*line :199:14*/_Ctype_EVP_CIPHER /*line :199:26*/
	switch len(c.key) * 8 {
	case 128:
		cipher = ( /*line :202:12*/_Cfunc__goboringcrypto_EVP_aes_128_cbc /*line :202:44*/)()
	case 192:
		cipher = ( /*line :204:12*/_Cfunc__goboringcrypto_EVP_aes_192_cbc /*line :204:44*/)()
	case 256:
		cipher = ( /*line :206:12*/_Cfunc__goboringcrypto_EVP_aes_256_cbc /*line :206:44*/)()
	default:
		panic("crypto/boring: unsupported key length")
	}
	if  /*line :210:5*/_Ctype_int /*line :210:10*/(1) != func() _Ctype_int{ _cgo0 := /*line :210:53*/x.ctx; _cgo1 := /*line :210:60*/cipher; var _cgo2 *_Ctype_struct_engine_st = /*line :210:68*/nil; var _cgo3 *_Ctype_uchar = /*line :210:73*/k; var _cgo4 *_Ctype_uchar = /*line :210:76*/vec; var _cgo5 _Ctype_int = /*line :210:81*/x.mode; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :210:88*/_Cfunc__goboringcrypto_EVP_CipherInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() {
		panic("cipher: unable to initialize EVP cipher ctx")
	}

	runtime.SetFinalizer(x, (*aesCBC).finalize)

	return x
}

func (c *aesCBC) finalize() {
	func() { _cgo0 := /*line :220:40*/c.ctx; _cgoCheckPointer(_cgo0, nil); /*line :220:46*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_free(_cgo0); }()
}

func (c *aesCipher) NewCBCDecrypter(iv []byte) cipher.BlockMode {
	x := &aesCBC{key: c.key, mode: ( /*line :224:33*/_Ciconst_GO_AES_DECRYPT /*line :224:48*/)}
	copy(x.iv[:], iv)

	x.ctx = ( /*line :227:10*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_new /*line :227:45*/)()
	if x.ctx == nil {
		panic("cipher: unable to create EVP cipher ctx")
	}

	k := (* /*line :232:9*/_Ctype_uchar /*line :232:16*/)(unsafe.Pointer(&x.key[0]))
	vec := (* /*line :233:11*/_Ctype_uchar /*line :233:18*/)(unsafe.Pointer(&x.iv[0]))

	var cipher * /*line :235:14*/_Ctype_EVP_CIPHER /*line :235:26*/
	switch len(c.key) * 8 {
	case 128:
		cipher = ( /*line :238:12*/_Cfunc__goboringcrypto_EVP_aes_128_cbc /*line :238:44*/)()
	case 192:
		cipher = ( /*line :240:12*/_Cfunc__goboringcrypto_EVP_aes_192_cbc /*line :240:44*/)()
	case 256:
		cipher = ( /*line :242:12*/_Cfunc__goboringcrypto_EVP_aes_256_cbc /*line :242:44*/)()
	default:
		panic("crypto/boring: unsupported key length")
	}
	if  /*line :246:5*/_Ctype_int /*line :246:10*/(1) != func() _Ctype_int{ _cgo0 := /*line :246:53*/x.ctx; _cgo1 := /*line :246:60*/cipher; var _cgo2 *_Ctype_struct_engine_st = /*line :246:68*/nil; var _cgo3 *_Ctype_uchar = /*line :246:73*/k; var _cgo4 *_Ctype_uchar = /*line :246:76*/vec; var _cgo5 _Ctype_int = /*line :246:81*/x.mode; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :246:88*/_Cfunc__goboringcrypto_EVP_CipherInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() {
		panic("cipher: unable to initialize EVP cipher ctx")
	}
	if  /*line :249:5*/_Ctype_int /*line :249:10*/(1) != func() _Ctype_int{ _cgo0 := /*line :249:62*/x.ctx; var _cgo1 _Ctype_int = /*line :249:69*/0; _cgoCheckPointer(_cgo0, nil); return /*line :249:71*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_set_padding(_cgo0, _cgo1); }() {
		panic("cipher: unable to set padding")
	}

	runtime.SetFinalizer(x, (*aesCBC).finalize)
	return x
}

type aesCTR struct {
	key        []byte
	iv         [aesBlockSize]byte
	ctx        * /*line :260:14*/_Ctype_EVP_CIPHER_CTX /*line :260:30*/
	num         /*line :261:13*/_Ctype_uint /*line :261:19*/
	ecount_buf [16] /*line :262:17*/_Ctype_uint8_t /*line :262:26*/
}

func (x *aesCTR) XORKeyStream(dst, src []byte) {
	if inexactOverlap(dst, src) {
		panic("crypto/cipher: invalid buffer overlap")
	}
	if len(dst) < len(src) {
		panic("crypto/cipher: output smaller than input")
	}
	if len(src) == 0 {
		return
	}
	func() { _cgo0 := /*line :276:3*/x.ctx; var _cgo1 *_Ctype_uint8_t = /*line :277:3*/(*_Ctype_uint8_t /*line :277:14*/)(unsafe.Pointer(&src[0])); var _cgo2 *_Ctype_uint8_t = /*line :278:3*/(*_Ctype_uint8_t /*line :278:14*/)(unsafe.Pointer(&dst[0])); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :279:11*/(len(src)); _cgoCheckPointer(_cgo0, nil); /*line :279:22*/_Cfunc__goboringcrypto_EVP_AES_ctr128_enc(_cgo0, _cgo1, _cgo2, _cgo3); }()
	runtime.KeepAlive(x)
}

func (c *aesCipher) NewCTR(iv []byte) cipher.Stream {
	x := &aesCTR{key: c.key}
	copy(x.iv[:], iv)

	x.ctx = ( /*line :287:10*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_new /*line :287:45*/)()
	if x.ctx == nil {
		panic("cipher: unable to create EVP cipher ctx")
	}

	k := (* /*line :292:9*/_Ctype_uchar /*line :292:16*/)(unsafe.Pointer(&x.key[0]))
	vec := (* /*line :293:11*/_Ctype_uchar /*line :293:18*/)(unsafe.Pointer(&x.iv[0]))

	switch len(c.key) * 8 {
	case 128:
		if  /*line :297:6*/_Ctype_int /*line :297:11*/(1) != func() _Ctype_int{ _cgo0 := /*line :297:55*/x.ctx; _cgo1 := _Cfunc__goboringcrypto_EVP_aes_128_ctr /*line :297:95*/(); var _cgo2 *_Ctype_struct_engine_st = /*line :297:99*/nil; var _cgo3 *_Ctype_uchar = /*line :297:104*/k; var _cgo4 *_Ctype_uchar = /*line :297:107*/vec; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :297:111*/_Cfunc__goboringcrypto_EVP_EncryptInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() {
			panic("cipher: unable to initialize EVP cipher ctx")
		}
	case 192:
		if  /*line :301:6*/_Ctype_int /*line :301:11*/(1) != func() _Ctype_int{ _cgo0 := /*line :301:55*/x.ctx; _cgo1 := _Cfunc__goboringcrypto_EVP_aes_192_ctr /*line :301:95*/(); var _cgo2 *_Ctype_struct_engine_st = /*line :301:99*/nil; var _cgo3 *_Ctype_uchar = /*line :301:104*/k; var _cgo4 *_Ctype_uchar = /*line :301:107*/vec; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :301:111*/_Cfunc__goboringcrypto_EVP_EncryptInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() {
			panic("cipher: unable to initialize EVP cipher ctx")
		}
	case 256:
		if  /*line :305:6*/_Ctype_int /*line :305:11*/(1) != func() _Ctype_int{ _cgo0 := /*line :305:55*/x.ctx; _cgo1 := _Cfunc__goboringcrypto_EVP_aes_256_ctr /*line :305:95*/(); var _cgo2 *_Ctype_struct_engine_st = /*line :305:99*/nil; var _cgo3 *_Ctype_uchar = /*line :305:104*/k; var _cgo4 *_Ctype_uchar = /*line :305:107*/vec; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :305:111*/_Cfunc__goboringcrypto_EVP_EncryptInit_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() {
			panic("cipher: unable to initialize EVP cipher ctx")
		}
	}

	runtime.SetFinalizer(x, (*aesCTR).finalize)

	return x
}

func (c *aesCTR) finalize() {
	func() { _cgo0 := /*line :316:40*/c.ctx; _cgoCheckPointer(_cgo0, nil); /*line :316:46*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_free(_cgo0); }()
}

type aesGCM struct {
	key []byte
	tls bool
}

const (
	gcmBlockSize         = 16
	gcmTagSize           = 16
	gcmStandardNonceSize = 12
)

type aesNonceSizeError int

func (n aesNonceSizeError) Error() string {
	return "crypto/aes: invalid GCM nonce size " + strconv.Itoa(int(n))
}

type noGCM struct {
	cipher.Block
}

func (c *aesCipher) NewGCM(nonceSize, tagSize int) (cipher.AEAD, error) {
	if !ExecutingTest() || IsStrictFips() {
		if nonceSize != gcmStandardNonceSize {
			return nil, errors.New("crypto/aes: GCM nonce size can't be non-standard")
		}
		if tagSize != gcmTagSize {
			return nil, errors.New("crypto/aes: GCM tag size can't be non-standard")
		}
	} else {
		// Be more lenient if we're running via a test binary so that
		// we don't have to be as invasive with skipping tests in the standard
		// library.
		if nonceSize != gcmStandardNonceSize && tagSize != gcmTagSize {
			return nil, errors.New("crypto/aes: GCM tag and nonce sizes can't be non-standard at the same time")
		}
		// Fall back to standard library for GCM with non-standard nonce or tag size.
		if nonceSize != gcmStandardNonceSize {
			return cipher.NewGCMWithNonceSize(&noGCM{c}, nonceSize)
		}
		if tagSize != gcmTagSize {
			return cipher.NewGCMWithTagSize(&noGCM{c}, tagSize)
		}
	}
	return c.newGCM(false)
}

// NewGCMTLS returns a GCM cipher specific to TLS
// and should not be used for non-TLS purposes.
func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
	return c.(*aesCipher).NewGCMTLS()
}

func (c *aesCipher) NewGCMTLS() (cipher.AEAD, error) {
	return c.newGCM(true)
}

func (c *aesCipher) newGCM(tls bool) (cipher.AEAD, error) {
	keyLen := len(c.key) * 8

	if keyLen != 128 && keyLen != 256 {
		if ExecutingTest() {
			// Fall back to standard library for GCM with non-standard key size.
			return cipher.NewGCMWithNonceSize(&noGCM{c}, gcmStandardNonceSize)
		}
		// Return error for GCM with non-standard key size.
		return nil, fail("GCM invoked with non-standard key size")
	}

	g := &aesGCM{key: c.key, tls: tls}
	if g.NonceSize() != gcmStandardNonceSize {
		panic("boringcrypto: internal confusion about nonce size")
	}
	if g.Overhead() != gcmTagSize {
		panic("boringcrypto: internal confusion about tag size")
	}

	return g, nil
}

func (g *aesGCM) NonceSize() int {
	return gcmStandardNonceSize
}

func (g *aesGCM) Overhead() int {
	return gcmTagSize
}

// base returns the address of the underlying array in b,
// being careful not to panic when b has zero length.
func base(b []byte) * /*line :409:22*/_Ctype_uint8_t /*line :409:31*/ {
	if len(b) == 0 {
		return nil
	}
	return (* /*line :413:11*/_Ctype_uint8_t /*line :413:20*/)(unsafe.Pointer(&b[0]))
}

func (g *aesGCM) Seal(dst, nonce, plaintext, additionalData []byte) []byte {
	if len(nonce) != gcmStandardNonceSize {
		panic("cipher: incorrect nonce length given to GCM")
	}
	if uint64(len(plaintext)) > ((1<<32)-2)*aesBlockSize || len(plaintext)+gcmTagSize < len(plaintext) {
		panic("cipher: message too large for GCM")
	}
	if len(dst)+len(plaintext)+gcmTagSize < len(dst) {
		panic("cipher: message too large for buffer")
	}

	// Make room in dst to append plaintext+overhead.
	n := len(dst)
	for cap(dst) < n+len(plaintext)+gcmTagSize {
		dst = append(dst[:cap(dst)], 0)
	}
	dst = dst[:n+len(plaintext)+gcmTagSize]

	// Check delayed until now to make sure len(dst) is accurate.
	if inexactOverlap(dst[n:], plaintext) {
		panic("cipher: invalid buffer overlap")
	}

	var ciphertextLen  /*line :439:20*/_Ctype_size_t /*line :439:28*/

	if ok := ( /*line :441:11*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_seal /*line :441:47*/)(
		(* /*line :442:5*/_Ctype_uint8_t /*line :442:14*/)(unsafe.Pointer(&dst[n])),
		base(nonce), base(additionalData),  /*line :443:38*/_Ctype_size_t /*line :443:46*/(len(additionalData)),
		base(plaintext),  /*line :444:20*/_Ctype_size_t /*line :444:28*/(len(plaintext)), &ciphertextLen,
		base(g.key),  /*line :445:16*/_Ctype_int /*line :445:21*/(len(g.key)*8)); ok != 1 {
		panic("boringcrypto: EVP_CIPHER_CTX_seal fail")
	}
	runtime.KeepAlive(g)

	if ciphertextLen !=  /*line :450:22*/_Ctype_size_t /*line :450:30*/(len(plaintext)+gcmTagSize) {
		panic("boringcrypto: [seal] internal confusion about GCM tag size")
	}
	return dst[:n+int(ciphertextLen)]
}

var errOpen = errors.New("cipher: message authentication failed")

func (g *aesGCM) Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) {
	if len(nonce) != gcmStandardNonceSize {
		panic("cipher: incorrect nonce length given to GCM")
	}
	if len(ciphertext) < gcmTagSize {
		return nil, errOpen
	}
	if uint64(len(ciphertext)) > ((1<<32)-2)*aesBlockSize+gcmTagSize {
		return nil, errOpen
	}

	// Make room in dst to append ciphertext without tag.
	n := len(dst)
	for cap(dst) < n+len(ciphertext)-gcmTagSize {
		dst = append(dst[:cap(dst)], 0)
	}
	dst = dst[:n+len(ciphertext)-gcmTagSize]

	// Check delayed until now to make sure len(dst) is accurate.
	if inexactOverlap(dst[n:], ciphertext) {
		panic("cipher: invalid buffer overlap")
	}

	tag := ciphertext[len(ciphertext)-gcmTagSize:]

	var outLen  /*line :483:13*/_Ctype_size_t /*line :483:21*/

	ok := ( /*line :485:8*/_Cfunc__goboringcrypto_EVP_CIPHER_CTX_open /*line :485:44*/)(
		base(ciphertext),  /*line :486:21*/_Ctype_int /*line :486:26*/(len(ciphertext)-gcmTagSize),
		base(additionalData),  /*line :487:25*/_Ctype_int /*line :487:30*/(len(additionalData)),
		base(tag), base(g.key),  /*line :488:27*/_Ctype_int /*line :488:32*/(len(g.key)*8),
		base(nonce),  /*line :489:16*/_Ctype_int /*line :489:21*/(len(nonce)),
		base(dst[n:]), &outLen)
	runtime.KeepAlive(g)
	if ok == 0 {
		// Zero output buffer on error.
		for i := range dst {
			dst[i] = 0
		}
		return nil, errOpen
	}
	if outLen !=  /*line :499:15*/_Ctype_size_t /*line :499:23*/(len(ciphertext)-gcmTagSize) {
		panic("boringcrypto: [open] internal confusion about GCM tag size")
	}
	return dst[:n+int(outLen)], nil
}

func anyOverlap(x, y []byte) bool {
	return len(x) > 0 && len(y) > 0 &&
		uintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&
		uintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))
}

func inexactOverlap(x, y []byte) bool {
	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
		return false
	}
	return anyOverlap(x, y)
}
