// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/lib/golang/src/vendor/github.com/golang-fips/openssl-fips/openssl/openssl.go:1:1
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && !android && !cmd_go_bootstrap && !msan && !no_openssl && !static
// +build linux,!android,!cmd_go_bootstrap,!msan,!no_openssl,!static

package openssl

/*
#cgo LDFLAGS: -ldl

#include "goopenssl.h"
*/
import _ "unsafe"
import (
	"encoding/binary"
	"errors"
	"fmt"
	"math/bits"
	"os"
	"runtime"
	"unsafe"
)

const (
	fipsOn  =  /*line :27:12*/_Ctype_int /*line :27:17*/(1)
	fipsOff =  /*line :28:12*/_Ctype_int /*line :28:17*/(0)
)

const GoStrictFipsEnv = "GOLANG_STRICT_FIPS"

const (
	OPENSSL_VERSION_1_1_0 = uint64( /*line :34:33*/_Ctype_ulong /*line :34:40*/(0x10100000))
	OPENSSL_VERSION_1_1_1 = uint64( /*line :35:33*/_Ctype_ulong /*line :35:40*/(0x10101000))
	OPENSSL_VERSION_3_0_0 = uint64( /*line :36:33*/_Ctype_ulong /*line :36:40*/(0x30000000))
)

// Enabled controls whether FIPS crypto is enabled.
var enabled = false

// When this variable is true, the go crypto API will panic when a caller
// tries to use the API in a non-compliant manner.  When this is false, the
// go crypto API will allow existing go crypto APIs to be used even
// if they aren't FIPS compliant.  However, all the underlying crypto operations
// will still be done by OpenSSL.
var strictFIPS = false

var nativeEndian binary.ByteOrder

func init() {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	buf := [2]byte{}
	*(*uint16)(unsafe.Pointer(&buf[0])) = uint16(0xABCD)

	switch buf {
	case [2]byte{0xCD, 0xAB}:
		nativeEndian = binary.LittleEndian
	case [2]byte{0xAB, 0xCD}:
		nativeEndian = binary.BigEndian
	default:
		panic("Could not determine native endianness.")
	}

	// Check if we can `dlopen` OpenSSL
	if ( /*line :68:5*/_Cfunc__goboringcrypto_DLOPEN_OPENSSL /*line :68:36*/)() == ( /*line :68:43*/_Cmacro_NULL() /*line :68:48*/) {
		return
	}

	// Initialize the OpenSSL library.
	( /*line :73:2*/_Cfunc__goboringcrypto_OPENSSL_setup /*line :73:32*/)()

	// Check to see if the system is running in FIPS mode, if so
	// enable "boring" mode to call into OpenSSL for FIPS compliance.
	if fipsModeEnabled() {
		enableBoringFIPSMode()
	}
}

func openSSLVersion() uint64 {
	return uint64(( /*line :83:16*/_Cfunc__goboringcrypto_internal_OPENSSL_VERSION_NUMBER /*line :83:64*/)())
}

func enableBoringFIPSMode() {
	enabled = true

	if os.Getenv(GoStrictFipsEnv) == "1" {
		strictFIPS = true
	}

	if ( /*line :93:5*/_Cfunc__goboringcrypto_OPENSSL_thread_setup /*line :93:42*/)() != 1 {
		panic("boringcrypto: OpenSSL thread setup failed")
	}
}

func fipsModeEnabled() bool {
	// Due to the way providers work in openssl 3, the FIPS methods are not
	// necessarily going to be available for us to load based on the GOLANG_FIPS
	// environment variable alone. For now, we must rely on the config to tell
	// us if the provider is configured and active.
	fipsConfigured := ( /*line :103:20*/_Cfunc__goboringcrypto_FIPS_mode /*line :103:46*/)() == fipsOn
	openSSLVersion := openSSLVersion()
	if openSSLVersion >= OPENSSL_VERSION_3_0_0 {
		if !fipsConfigured && os.Getenv("GOLANG_FIPS") == "1" {
			panic("GOLANG_FIPS=1 specified but OpenSSL FIPS provider is not configured")
		}
		return fipsConfigured

	} else {
		return os.Getenv("GOLANG_FIPS") == "1" || fipsConfigured
	}
}

var randstub bool

func RandStubbed() bool {
	return randstub
}

func StubOpenSSLRand() {
	if !randstub {
		randstub = true
		( /*line :125:3*/_Cfunc__goboringcrypto_stub_openssl_rand /*line :125:37*/)()
	}
}

func RestoreOpenSSLRand() {
	if randstub {
		randstub = false
		( /*line :132:3*/_Cfunc__goboringcrypto_restore_openssl_rand /*line :132:40*/)()
	}
}

func hasSuffix(s, t string) bool {
	return len(s) > len(t) && s[len(s)-len(t):] == t
}

func PanicIfStrictFIPS(msg string) {
	if IsStrictFips() {
		panic(msg)
	}
}

func IsStrictFips() bool {
	return os.Getenv(GoStrictFipsEnv) == "1" || strictFIPS
}

func NewOpenSSLError(msg string) error {
	var e  /*line :151:8*/_Ctype_ulong /*line :151:15*/
	message := fmt.Sprintf("\n%v\nopenssl error(s):", msg)
	for {
		var buf [256] /*line :154:16*/_Ctype_char /*line :154:22*/
		var file, fnc, data * /*line :155:24*/_Ctype_char /*line :155:30*/
		var line, flags  /*line :156:19*/_Ctype_int /*line :156:24*/
		e = func() _Ctype_ulong{ _cgoBase0 := /*line :157:52*/&file; _cgo0 := _cgoBase0; var _cgo1 *_Ctype_int = /*line :157:59*/&line; _cgoBase2 := /*line :157:66*/&fnc; _cgo2 := _cgoBase2; _cgoBase3 := /*line :157:72*/&data; _cgo3 := _cgoBase3; var _cgo4 *_Ctype_int = /*line :157:79*/&flags; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :157:86*/_Cfunc__goboringcrypto_internal_ERR_get_error_all(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
		if e == 0 {
			break
		}

		( /*line :162:3*/_Cfunc__goboringcrypto_internal_ERR_error_string_n /*line :162:47*/)(e, (* /*line :162:54*/_Ctype_uchar /*line :162:61*/)(unsafe.Pointer(&buf[0])),  /*line :162:89*/_Ctype_size_t /*line :162:97*/(len(buf)))
		message = fmt.Sprintf(
			"%v\nfile: %v\nline: %v\nfunction: %v\nflags: %v\nerror string: %s\n",
			message, ( /*line :165:13*/_Cfunc_GoString /*line :165:22*/)(file), line, ( /*line :165:37*/_Cfunc_GoString /*line :165:46*/)(fnc), flags, ( /*line :165:61*/_Cfunc_GoString /*line :165:70*/)(&(buf[0])))

	}
	return errors.New(message)
}

// Unreachable marks code that should be unreachable
// when FIPS mode. It panics only when
// the system is in FIPS mode.
func Unreachable() {
	if Enabled() {
		panic("openssl: invalid code execution")
	}
}

// UnreachableExceptTests marks code that should be unreachable
// when FIPS mode is active. It panics only when the system is in FIPS mode
// and not executing under tests.
func UnreachableExceptTests() {
	name := os.Args[0]
	if Enabled() && !ExecutingTest() {
		println("openssl: unexpected code execution in", name)
		panic("openssl: invalid code execution")
	}
}

// ExecutingTest returns a boolean indicating if we're
// executing under a test binary or not.
func ExecutingTest() bool {
	name := os.Args[0]
	return hasSuffix(name, "_test") || hasSuffix(name, ".test")
}

type fail string

func (e fail) Error() string { return "boringcrypto: " + string(e) + " failed" }

const wordBytes = bits.UintSize / 8

// Reverse each limb of z.
func (z BigInt) byteSwap() {
	for i, d := range z {
		var n uint = 0
		for j := 0; j < wordBytes; j++ {
			n |= uint(byte(d)) << (8 * (wordBytes - j - 1))
			d >>= 8
		}
		z[i] = n
	}
}

func wbase(b BigInt) * /*line :216:23*/_Ctype_uint8_t /*line :216:32*/ {
	if len(b) == 0 {
		return nil
	}
	return (* /*line :220:11*/_Ctype_uint8_t /*line :220:20*/)(unsafe.Pointer(&b[0]))
}

func bigToBN(x BigInt) * /*line :223:25*/_Ctype_GO_BIGNUM /*line :223:36*/ {
	if nativeEndian == binary.BigEndian {
		z := make(BigInt, len(x))
		copy(z, x)
		z.byteSwap()
		x = z
	}
	// Limbs are always ordered in LSB first, so we can safely apply
	// BN_lebin2bn regardless of host endianness.
	return ( /*line :232:9*/_Cfunc__goboringcrypto_BN_lebin2bn /*line :232:37*/)(wbase(x),  /*line :232:49*/_Ctype_int /*line :232:54*/(len(x)*wordBytes), nil)
}

func bnToBig(bn * /*line :235:18*/_Ctype_GO_BIGNUM /*line :235:29*/) BigInt {
	x := make(BigInt, (func() _Ctype_int{ _cgo0 := /*line :236:52*/bn; _cgoCheckPointer(_cgo0, nil); return /*line :236:55*/_Cfunc__goboringcrypto_BN_num_bytes(_cgo0); }()+wordBytes-1)/wordBytes)
	// Limbs are always ordered in LSB first, so we can safely apply
	// BN_bn2lebinpad regardless of host endianness.
	if func() _Ctype_int{ _cgo0 := /*line :239:38*/bn; var _cgo1 *_Ctype_uchar = /*line :239:42*/wbase(x); var _cgo2 _Ctype_int = _Ctype_int /*line :239:57*/(len(x) * wordBytes); _cgoCheckPointer(_cgo0, nil); return /*line :239:76*/_Cfunc__goboringcrypto_BN_bn2lebinpad(_cgo0, _cgo1, _cgo2); }() == 0 {
		panic("boringcrypto: bignum conversion failed")
	}
	if nativeEndian == binary.BigEndian {
		x.byteSwap()
	}
	return x
}

func bigToBn(bnp ** /*line :248:20*/_Ctype_GO_BIGNUM /*line :248:31*/, b BigInt) bool {
	if *bnp != nil {
		func() { _cgo0 := /*line :250:29*/*bnp; _cgoCheckPointer(_cgo0, nil); /*line :250:34*/_Cfunc__goboringcrypto_BN_free(_cgo0); }()
		*bnp = nil
	}
	if b == nil {
		return true
	}
	bn := bigToBN(b)
	if bn == nil {
		return false
	}
	*bnp = bn
	return true
}

// noescape hides a pointer from escape analysis.  noescape is
// the identity function but escape analysis doesn't think the
// output depends on the input.  noescape is inlined and currently
// compiles down to zero instructions.
// USE CAREFULLY!
//
//go:nosplit
func noescape(p unsafe.Pointer) unsafe.Pointer {
	x := uintptr(p)
	return unsafe.Pointer(x ^ 0)
}

var zero byte

// addr converts p to its base addr, including a noescape along the way.
// If p is nil, addr returns a non-nil pointer, so that the result can always
// be dereferenced.
//
//go:nosplit
func addr(p []byte) *byte {
	if len(p) == 0 {
		return &zero
	}
	return (*byte)(noescape(unsafe.Pointer(&p[0])))
}
