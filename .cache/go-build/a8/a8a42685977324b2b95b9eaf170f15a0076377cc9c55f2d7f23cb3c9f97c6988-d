// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/lib/golang/src/vendor/github.com/golang-fips/openssl-fips/openssl/ecdsa.go:1:1
// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build linux && !android && !cmd_go_bootstrap && !msan && !no_openssl && !static
// +build linux,!android,!cmd_go_bootstrap,!msan,!no_openssl,!static

package openssl

// #include "goopenssl.h"
import _ "unsafe"
import (
	"crypto"
	"encoding/asn1"
	"errors"
	"math/big"
	"runtime"
	"unsafe"
)

type ecdsaSignature struct {
	R, S *big.Int
}

type PrivateKeyECDSA struct {
	key * /*line :26:7*/_Ctype_GO_EC_KEY /*line :26:18*/
}

func (k *PrivateKeyECDSA) finalize() {
	func() { _cgo0 := /*line :30:32*/k.key; _cgoCheckPointer(_cgo0, nil); /*line :30:38*/_Cfunc__goboringcrypto_EC_KEY_free(_cgo0); }()
}

type PublicKeyECDSA struct {
	key * /*line :34:7*/_Ctype_GO_EC_KEY /*line :34:18*/
}

func (k *PublicKeyECDSA) finalize() {
	func() { _cgo0 := /*line :38:32*/k.key; _cgoCheckPointer(_cgo0, nil); /*line :38:38*/_Cfunc__goboringcrypto_EC_KEY_free(_cgo0); }()
}

var errUnknownCurve = errors.New("boringcrypto: unknown elliptic curve")
var errUnsupportedCurve = errors.New("boringcrypto: unsupported elliptic curve")

func curveNID(curve string) ( /*line :44:30*/_Ctype_int /*line :44:35*/, error) {
	switch curve {
	case "P-224":
		if ExecutingTest() {
			return ( /*line :48:11*/_Ciconst_GO_NID_secp224r1 /*line :48:28*/), nil
		}
		return 0, errUnsupportedCurve
	case "P-256":
		return ( /*line :52:10*/_Ciconst_GO_NID_X9_62_prime256v1 /*line :52:34*/), nil
	case "P-384":
		return ( /*line :54:10*/_Ciconst_GO_NID_secp384r1 /*line :54:27*/), nil
	case "P-521":
		return ( /*line :56:10*/_Ciconst_GO_NID_secp521r1 /*line :56:27*/), nil
	}
	return 0, errUnknownCurve
}

func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
	key, err := newECKey(curve, X, Y)
	if err != nil {
		return nil, err
	}
	k := &PublicKeyECDSA{key}
	// Note: Because of the finalizer, any time k.key is passed to cgo,
	// that call must be followed by a call to runtime.KeepAlive(k),
	// to make sure k is not collected (and finalized) before the cgo
	// call returns.
	runtime.SetFinalizer(k, (*PublicKeyECDSA).finalize)
	return k, nil
}

func newECKey(curve string, X, Y BigInt) (* /*line :75:44*/_Ctype_GO_EC_KEY /*line :75:55*/, error) {
	nid, err := curveNID(curve)
	if err != nil {
		return nil, err
	}
	key := ( /*line :80:9*/_Cfunc__goboringcrypto_EC_KEY_new_by_curve_name /*line :80:50*/)(nid)
	if key == nil {
		return nil, NewOpenSSLError("EC_KEY_new_by_curve_name failed")
	}
	group := func() *_Ctype_struct_ec_group_st{ _cgo0 := /*line :84:47*/key; _cgoCheckPointer(_cgo0, nil); return /*line :84:51*/_Cfunc__goboringcrypto_EC_KEY_get0_group(_cgo0); }()
	pt := func() *_Ctype_struct_ec_point_st{ _cgo0 := /*line :85:39*/group; _cgoCheckPointer(_cgo0, nil); return /*line :85:45*/_Cfunc__goboringcrypto_EC_POINT_new(_cgo0); }()
	if pt == nil {
		func() { _cgo0 := /*line :87:33*/key; _cgoCheckPointer(_cgo0, nil); /*line :87:37*/_Cfunc__goboringcrypto_EC_KEY_free(_cgo0); }()
		return nil, NewOpenSSLError("EC_POINT_new failed")
	}
	bx := bigToBN(X)
	by := bigToBN(Y)
	ok := bx != nil && by != nil && func() _Ctype_int{ _cgo0 := /*line :92:88*/group; _cgo1 := /*line :92:95*/pt; _cgo2 := /*line :92:99*/bx; _cgo3 := /*line :92:103*/by; var _cgo4 *_Ctype_struct_bignum_ctx = /*line :92:107*/nil; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :92:111*/_Cfunc__goboringcrypto_EC_POINT_set_affine_coordinates_GFp(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() != 0 &&
		func() _Ctype_int{ _cgo0 := /*line :93:43*/key; _cgo1 := /*line :93:48*/pt; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :93:51*/_Cfunc__goboringcrypto_EC_KEY_set_public_key(_cgo0, _cgo1); }() != 0
	if bx != nil {
		func() { _cgo0 := /*line :95:29*/bx; _cgoCheckPointer(_cgo0, nil); /*line :95:32*/_Cfunc__goboringcrypto_BN_free(_cgo0); }()
	}
	if by != nil {
		func() { _cgo0 := /*line :98:29*/by; _cgoCheckPointer(_cgo0, nil); /*line :98:32*/_Cfunc__goboringcrypto_BN_free(_cgo0); }()
	}
	func() { _cgo0 := /*line :100:34*/pt; _cgoCheckPointer(_cgo0, nil); /*line :100:37*/_Cfunc__goboringcrypto_EC_POINT_free(_cgo0); }()
	if !ok {
		func() { _cgo0 := /*line :102:33*/key; _cgoCheckPointer(_cgo0, nil); /*line :102:37*/_Cfunc__goboringcrypto_EC_KEY_free(_cgo0); }()
		return nil, NewOpenSSLError("EC_POINT_free failed")
	}
	return key, nil
}

func NewPrivateKeyECDSA(curve string, X, Y BigInt, D BigInt) (*PrivateKeyECDSA, error) {
	key, err := newECKey(curve, X, Y)
	if err != nil {
		return nil, err
	}
	bd := bigToBN(D)
	ok := bd != nil && func() _Ctype_int{ _cgo0 := /*line :114:62*/key; _cgo1 := /*line :114:67*/bd; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :114:70*/_Cfunc__goboringcrypto_EC_KEY_set_private_key(_cgo0, _cgo1); }() != 0
	if bd != nil {
		func() { _cgo0 := /*line :116:29*/bd; _cgoCheckPointer(_cgo0, nil); /*line :116:32*/_Cfunc__goboringcrypto_BN_free(_cgo0); }()
	}
	if !ok {
		func() { _cgo0 := /*line :119:33*/key; _cgoCheckPointer(_cgo0, nil); /*line :119:37*/_Cfunc__goboringcrypto_EC_KEY_free(_cgo0); }()
		return nil, NewOpenSSLError("EC_KEY_set_private_key failed")
	}
	k := &PrivateKeyECDSA{key}
	// Note: Because of the finalizer, any time k.key is passed to cgo,
	// that call must be followed by a call to runtime.KeepAlive(k),
	// to make sure k is not collected (and finalized) before the cgo
	// call returns.
	runtime.SetFinalizer(k, (*PrivateKeyECDSA).finalize)
	return k, nil
}

func HashSignECDSA(priv *PrivateKeyECDSA, hash []byte, h crypto.Hash) (*big.Int, *big.Int, error) {
	size := func() _Ctype_size_t{ _cgo0 := /*line :132:39*/priv.key; _cgoCheckPointer(_cgo0, nil); return /*line :132:48*/_Cfunc__goboringcrypto_ECDSA_size(_cgo0); }()
	sig := make([]byte, size)
	var sigLen  /*line :134:13*/_Ctype_size_t /*line :134:21*/
	md := cryptoHashToMD(h)
	if md == nil {
		panic("boring: invalid hash")
	}
	if func() _Ctype_int{ _cgo0 := /*line :139:34*/md; var _cgo1 *_Ctype_uint8_t = /*line :139:38*/base(hash); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :139:58*/(len(hash)); var _cgo3 *_Ctype_uint8_t = /*line :139:71*/(*_Ctype_uint8_t /*line :139:82*/)(unsafe.Pointer(&sig[0])); var _cgo4 *_Ctype_size_t = /*line :139:110*/&sigLen; _cgo5 := /*line :139:119*/priv.key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo5, nil); return /*line :139:128*/_Cfunc__goboringcrypto_ECDSA_sign(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() == 0 {
		return nil, nil, NewOpenSSLError("ECDSA_sign failed")
	}
	runtime.KeepAlive(priv)
	sig = sig[:sigLen]
	var esig ecdsaSignature
	if _, err := asn1.Unmarshal(sig, &esig); err != nil {
		return nil, nil, err
	}
	return esig.R, esig.S, nil
}

func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
	size := func() _Ctype_size_t{ _cgo0 := /*line :152:39*/priv.key; _cgoCheckPointer(_cgo0, nil); return /*line :152:48*/_Cfunc__goboringcrypto_ECDSA_size(_cgo0); }()
	sig := make([]byte, size)
	var sigLen  /*line :154:13*/_Ctype_uint /*line :154:19*/
	ok := func() _Ctype_int{ var _cgo0 _Ctype_int = /*line :155:46*/0; var _cgo1 *_Ctype_uchar = /*line :155:49*/base(hash); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :155:69*/(len(hash)); var _cgo3 *_Ctype_uchar = /*line :155:82*/(*_Ctype_uint8_t /*line :155:93*/)(unsafe.Pointer(&sig[0])); var _cgo4 *_Ctype_uint = /*line :155:121*/&sigLen; _cgo5 := /*line :155:130*/priv.key; _cgoCheckPointer(_cgo5, nil); return /*line :155:139*/_Cfunc__goboringcrypto_internal_ECDSA_sign(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() > 0
	if !ok {
		return nil, NewOpenSSLError(("ECDSA_sign failed"))
	}

	runtime.KeepAlive(priv)
	return sig[:sigLen], nil
}

func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
	ok := func() _Ctype_int{ var _cgo0 _Ctype_int = /*line :165:48*/0; var _cgo1 *_Ctype_uchar = /*line :165:51*/base(hash); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :165:71*/(len(hash)); var _cgo3 *_Ctype_uchar = /*line :165:84*/(*_Ctype_uint8_t /*line :165:95*/)(unsafe.Pointer(&sig[0])); var _cgo4 _Ctype_uint = _Ctype_uint /*line :165:129*/(len(sig)); _cgo5 := /*line :165:141*/pub.key; _cgoCheckPointer(_cgo5, nil); return /*line :165:149*/_Cfunc__goboringcrypto_internal_ECDSA_verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() > 0
	runtime.KeepAlive(pub)
	return ok
}

func HashVerifyECDSA(pub *PublicKeyECDSA, msg []byte, r, s *big.Int, h crypto.Hash) bool {
	md := cryptoHashToMD(h)
	if md == nil {
		panic("boring: invalid hash")
	}
	sig, err := asn1.Marshal(ecdsaSignature{r, s})
	if err != nil {
		return false
	}
	ok := func() _Ctype_int{ _cgo0 := /*line :179:39*/md; var _cgo1 *_Ctype_uint8_t = /*line :179:43*/base(msg); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :179:62*/(len(msg)); var _cgo3 *_Ctype_uint8_t = /*line :179:74*/(*_Ctype_uint8_t /*line :179:85*/)(unsafe.Pointer(&sig[0])); var _cgo4 _Ctype_uint = _Ctype_uint /*line :179:119*/(len(sig)); _cgo5 := /*line :179:131*/pub.key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo5, nil); return /*line :179:139*/_Cfunc__goboringcrypto_ECDSA_verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() > 0
	runtime.KeepAlive(pub)
	return ok
}

func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
	nid, err := curveNID(curve)
	if err != nil {
		return nil, nil, nil, err
	}
	key := ( /*line :189:9*/_Cfunc__goboringcrypto_EC_KEY_new_by_curve_name /*line :189:50*/)(nid)
	if key == nil {
		return nil, nil, nil, NewOpenSSLError("EC_KEY_new_by_curve_name failed")
	}
	defer func() func() { _cgo0 := /*line :193:38*/key; return func() { _cgoCheckPointer(_cgo0, nil); /*line :193:42*/_Cfunc__goboringcrypto_EC_KEY_free(_cgo0); }}()()
	if func() _Ctype_int{ _cgo0 := /*line :194:43*/key; _cgoCheckPointer(_cgo0, nil); return /*line :194:47*/_Cfunc__goboringcrypto_EC_KEY_generate_key(_cgo0); }() == 0 {
		return nil, nil, nil, NewOpenSSLError("EC_KEY_generate_key failed")
	}
	group := func() *_Ctype_struct_ec_group_st{ _cgo0 := /*line :197:47*/key; _cgoCheckPointer(_cgo0, nil); return /*line :197:51*/_Cfunc__goboringcrypto_EC_KEY_get0_group(_cgo0); }()
	pt := func() *_Ctype_struct_ec_point_st{ _cgo0 := /*line :198:49*/key; _cgoCheckPointer(_cgo0, nil); return /*line :198:53*/_Cfunc__goboringcrypto_EC_KEY_get0_public_key(_cgo0); }()
	bd := func() *_Ctype_struct_bignum_st{ _cgo0 := /*line :199:50*/key; _cgoCheckPointer(_cgo0, nil); return /*line :199:54*/_Cfunc__goboringcrypto_EC_KEY_get0_private_key(_cgo0); }()
	if pt == nil || bd == nil {
		return nil, nil, nil, NewOpenSSLError("EC_KEY_get0_private_key failed")
	}
	bx := ( /*line :203:8*/_Cfunc__goboringcrypto_BN_new /*line :203:31*/)()
	if bx == nil {
		return nil, nil, nil, NewOpenSSLError("BN_new failed")
	}
	defer func() func() { _cgo0 := /*line :207:34*/bx; return func() { _cgoCheckPointer(_cgo0, nil); /*line :207:37*/_Cfunc__goboringcrypto_BN_free(_cgo0); }}()()
	by := ( /*line :208:8*/_Cfunc__goboringcrypto_BN_new /*line :208:31*/)()
	if by == nil {
		return nil, nil, nil, NewOpenSSLError("BN_new failed")
	}
	defer func() func() { _cgo0 := /*line :212:34*/by; return func() { _cgoCheckPointer(_cgo0, nil); /*line :212:37*/_Cfunc__goboringcrypto_BN_free(_cgo0); }}()()
	if func() _Ctype_int{ _cgo0 := /*line :213:59*/group; _cgo1 := /*line :213:66*/pt; _cgo2 := /*line :213:70*/bx; _cgo3 := /*line :213:74*/by; var _cgo4 *_Ctype_struct_bignum_ctx = /*line :213:78*/nil; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :213:82*/_Cfunc__goboringcrypto_EC_POINT_get_affine_coordinates_GFp(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 0 {
		return nil, nil, nil, NewOpenSSLError("EC_POINT_get_affine_coordinates_GFp failed")
	}
	return bnToBig(bx), bnToBig(by), bnToBig(bd), nil
}
