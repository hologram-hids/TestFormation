// Code generated by cmd/cgo; DO NOT EDIT.

//line /usr/lib/golang/src/vendor/github.com/golang-fips/openssl-fips/openssl/evp.go:1:1
//go:build linux && !android && !cmd_go_bootstrap && !msan && !no_openssl
// +build linux,!android,!cmd_go_bootstrap,!msan,!no_openssl

package openssl; import _cgo_unsafe "unsafe"

// #include "goopenssl.h"
import _ "unsafe"

func generateEVPPKey(id  /*line :9:25*/_Ctype_int /*line :9:30*/, bits int, curve string) (* /*line :9:58*/_Ctype_GO_EVP_PKEY /*line :9:71*/, error) {
	if (bits == 0 && curve == "") || (bits != 0 && curve != "") {
		return nil, fail("incorrect generateEVPPKey parameters")
	}
	ctx := ( /*line :13:9*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_new_id /*line :13:45*/)(id, nil)
	if ctx == nil {
		return nil, NewOpenSSLError("EVP_PKEY_CTX_new_id failed")
	}
	defer func() func() { _cgo0 := /*line :17:44*/ctx; return func() { _cgoCheckPointer(_cgo0, nil); /*line :17:48*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_free(_cgo0); }}()()
	if func() _Ctype_int{ _cgo0 := /*line :18:44*/ctx; _cgoCheckPointer(_cgo0, nil); return /*line :18:48*/_Cfunc__goboringcrypto_EVP_PKEY_keygen_init(_cgo0); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_keygen_init failed")
	}
	if bits != 0 {
		if func() _Ctype_int{ _cgo0 := /*line :22:42*/ctx; var _cgo1 _Ctype_int = /*line :22:47*/id; var _cgo2 _Ctype_int = /*line :22:51*/-1; var _cgo3 _Ctype_int = /*line :22:55*/_Ciconst_GO_EVP_PKEY_CTRL_RSA_KEYGEN_BITS /*line :22:89*/; var _cgo4 _Ctype_int = _Ctype_int /*line :22:96*/(bits); var _cgo5 _cgo_unsafe.Pointer = /*line :22:104*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :22:108*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_ctrl(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() != 1 {
			return nil, NewOpenSSLError("EVP_PKEY_CTX_ctrl failed")
		}
	}
	if curve != "" {
		nid, err := curveNID(curve)
		if err != nil {
			return nil, err
		}
		if func() _Ctype_int{ _cgo0 := /*line :31:42*/ctx; var _cgo1 _Ctype_int = /*line :31:47*/id; var _cgo2 _Ctype_int = /*line :31:51*/-1; var _cgo3 _Ctype_int = /*line :31:55*/_Ciconst_GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID /*line :31:95*/; var _cgo4 _Ctype_int = /*line :31:97*/nid; var _cgo5 _cgo_unsafe.Pointer = /*line :31:102*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :31:106*/_Cfunc__goboringcrypto_EVP_PKEY_CTX_ctrl(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() != 1 {
			return nil, NewOpenSSLError("EVP_PKEY_CTX_ctrl failed")
		}
	}
	var pkey * /*line :35:12*/_Ctype_GO_EVP_PKEY /*line :35:25*/
	if func() _Ctype_int{ _cgo0 := /*line :36:39*/ctx; _cgoBase1 := /*line :36:44*/&pkey; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :36:50*/_Cfunc__goboringcrypto_EVP_PKEY_keygen(_cgo0, _cgo1); }() != 1 {
		return nil, NewOpenSSLError("EVP_PKEY_keygen failed")
	}
	return pkey, nil
}

// getECKey returns the EC_KEY from pkey.
// If pkey does not contain an EC_KEY it panics.
// The returned key should not be freed.
func getECKey(pkey * /*line :45:21*/_Ctype_GO_EVP_PKEY /*line :45:34*/) (key * /*line :45:42*/_Ctype_GO_EC_KEY /*line :45:53*/) {
	key = func() *_Ctype_struct_ec_key_st{ _cgo0 := /*line :46:47*/pkey; _cgoCheckPointer(_cgo0, nil); return /*line :46:52*/_Cfunc__goboringcrypto_EVP_PKEY_get0_EC_KEY(_cgo0); }()
	if key == nil {
		panic("pkey does not contain an EC_KEY")
	}
	return key
}
